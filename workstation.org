#+TITLE: Workstation
* Background & Introduction
This is my workstation configuration. I have had a few different setups over the years, so this one is still a bit of a
work in progress. Honestly, accomplishing this is a lot harder than I expected.

This time around, I have decided to try [[https://nixos.org/][nix]]. Nix is a really interesting way to configure your machine. However, this is not a
guide to nix itself, so I should link to a better one. Primarily, nix gives me faith that my setup will be rebuildable under
a new set of conditions, and can itself be a firm foundation upon which to build additional tooling for myself.

I have no idea if anyone will ever read this, but from personal experience, these workstation projects are easy to put
aside for a long time, and then you come back and can't remember how things were built.

That brings me to another point: this project is mostly written with literate org mode. This gives me an easy way to document
my thoughts as I work, and also explore using org mode for this task. I did this same thing a long time ago with my old
dotfiles setup, and I liked it, but everything else about it was a massive pain, so it was eventually abandoned. If you want
to see how this works, you should view this file raw. When github renders org mode source blocks, it omits all the headers.

Anyway, if you have any questions, feel free to shoot me an email or open an issue.
* README
Every code project needs a README. This really just contains super simple instructions along with a link to this file, which
contains all the important information.

#+begin_src md :tangle ./README.md  :noweb yes
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. clone this repo into `~/workstation` (does it have to be that location?)
2. cd `~/workstation` and run the `link.sh` script
3. run the `set-machine.sh` with the name of this machine (which links this machine settings).
3. run `install.sh`

# More Information

For more information, you should really read the <a href="workstation.org">workstation.org</a> file.
#+end_src
* Makefile
The first command is used to tangle ~workstation.org~.

#+begin_src makefile :tangle ./Makefile  :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

tangle:
	emacs -q -l lib/tangle-file.el --batch --tangle

build:
	home-manager build

switch:
	home-manager switch -b old

.PHONY: tangle build switch
#+end_src

And a little emacs lisp that goes with the tangle process:

#+begin_src emacs-lisp :tangle ./lib/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

;; WARNING: This file is managed by tangling workstation.org. Do not edit directly!
(add-to-list 'command-switch-alist '("--tangle" . do-tangle))

(defun do-tangle (arg)
  "Do the tangle. ARG is ignored."
  (find-file "workstation.org")
  (org-babel-tangle))

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
* literate programming with org mode

* Bootstrap process
Before I can start using nix, a number of things need to happen. This is called the bootstrap process.

1. ~nix~ needs to be installed.
2. ~home-manager~ needs to be installed.
3. ~home-manager~ file ~home.nix~ needs to be linked to correct location.
4. ~set-machine.sh~ must be run to set the symlink to the current machine. This provides machine-specific
   settings. I *might* be able to do this better somehow though.

** Nix installation
It appears that this line will set up nix on both on laptop and GH action runner just fine.
I worry that it might not work correctly for linux systems though, so I have a TODO to revisit this.

#+NAME: setup-nix
#+BEGIN_SRC sh
  # https://nixos.org/nix/manual/#sect-macos-installation
  sh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume
  source $HOME/.nix-profile/etc/profile.d/nix.sh
#+END_SRC

This used to be problematic to set this up in Catalina because of OS X read-only root directory nonsense.
Nowadays the installer handles this though, but I have had it fail before, so be aware.
(I *think* the cause of the failure was that I had old nix stuff still around from an earlier rebuild, and
running the commands to delete the volumes, remove the mounts, etc, seemed to work)
** Home Manager Installation
Before we can run home manager via nix, we need to actually install it.

#+NAME: setup-home-manager
#+begin_src sh

# add channels for home manager
nix-channel --add https://github.com/rycee/home-manager/archive/master.tar.gz home-manager
nix-channel --update

# if any files that home manager replaces already exist, the install process will fail
# using environment variable here will get install to behave just like the switch command flag -b
export HOME_MANAGER_BACKUP_EXT=old
nix-shell '<home-manager>' -A install || {
  echo "first home manager install failed, but that is expected."
}

home-manager switch -b old
#+end_src

I think I may have resolved the reason this was "expectedly" failing, but anyway it shouldn't hurt anything to have the extra echo
and switches in there.
** NIV Installation
Install Niv. I kinda think this is unnecessary, but I need to see research and see if this is so.
#+NAME: setup-niv
#+BEGIN_SRC sh
nix-env -iA nixpkgs.niv
#+END_SRC
** install.sh
This script runs all of the mentioned code, in order.

#+BEGIN_SRC sh :tangle ./install.sh :shebang "#!/usr/bin/env bash" :noweb yes

# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail
# Set up nix
<<setup-nix>>

# Set up home manager
<<setup-home-manager>>

# Set up Niv
<<setup-niv>>

#+END_SRC
** link.sh
Set up symlinks. This should be done as part of the initial setup process.

The program ~home-manager~ expects the file ~home.nix~ to be in
~$HOME/.config/nixpkgs/home.nix~. This script establishes the file in that location.

#+BEGIN_SRC sh :tangle ./link.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -xeuo pipefail

# set up symlinks
mkdir -p $HOME/.config/nixpkgs/
ln -s `pwd`/home.nix $HOME/.config/nixpkgs/home.nix
#+END_SRC
** set-machine.sh
This script links a specific machine configuration to the file ~this-machine.nix~ so that
I can have per-machine-specific settings, specifically usernames, home directory paths, etc.

This script is bad and I really should clean it up, but it works OK for now.
FWIW, no src_bash[]{set -e} because IIRC some part of the script requires it (I think the $1 etc), and I dont want to figure out how to do it otherwise.
Not super sure, need to investigate this more. Or not.
#+BEGIN_SRC sh :tangle ./set-machine.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

if [[ "$@" == "" ]] ; then
    echo "you must provide a machine name"
    exit 1
fi

if [[ "$1" == "glamdring" ]] ; then
  ln -s machines/glamdring.nix this-machine.nix
  exit 0
fi

if [[ "$1" == "gh-runner" ]] ; then
  ln -s machines/gh-runner.nix this-machine.nix
  exit 0
fi

if [[ "$1" == "sesco" ]] ; then
  ln -s machines/sesco.nix this-machine.nix
  exit 0
fi

echo "machine name unrecognized!"
exit 1

#+END_SRC
* home.nix
The "main" file for home-manager. At this point, nix, home manager, etc have all been
set up.

** Loading nixpkgs from Niv
#+NAME: load-niv
#+BEGIN_SRC nix
  # Load specific nixpkgs reference via niv
  sources = import ./nix/sources.nix;
  nixpkgs = sources.nixpkgs;
  pkgs = import nixpkgs {};
  ctx2 = ctx // {pkgs = pkgs;};
#+END_SRC

If you are unfamiliar, niv gives you the ability to "lock" the set of packages that you
install from. This way, the next time you check out the repository, it will have the same
references as at the time it was committed.

The variable ~ctx2~ is "context", but with niv's pkgs instead. That way when I pass it to
other nix files, they will use it, too. (perhaps they should load and use niv directly though?
I need to think about that). The name "context" to me means
"whatever gets passed to the function in home.nix". I really have no idea what to call it.
** emacs.nix
I wrote this file so that I could keep things separated, and my emacs configuration is in a single spot.
Since I neded up finding the nix-doom-emacs package, it seems like the need for this is gone. Maybe
I will inline it into ~home.nix~, I dunno.
#+begin_src nix :tangle ./emacs.nix :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
{ config, lib, pkgs, ... }:

{
  doom-emacs = pkgs.callPackage (builtins.fetchTarball {
    url = https://github.com/vlaci/nix-doom-emacs/archive/c440f4afe4ff2d38d2beb40d7e4bcfa2496f60c2.tar.gz; # version hash instead of master
  }) {
    doomPrivateDir = ./doom.d;  # Directory containing your config.el init.el
                                # and packages.el files
    extraPackages = epkgs: [
      epkgs.nix-mode
      epkgs.vterm
    ];
  };

  packages = [
    pkgs.ripgrep # required SPC-* / +default/search-project-for-symbol-at-point
  ];

  files = {
    ".emacs.d/init.el".text = ''
    ;; loads doom from nix store
    (load "default.el")
    '';
  };
}
#+end_src
** dotfiles.nix
Right now these are mostly all boring copies from my old setup.
#+begin_src nix :tangle ./dotfiles.nix :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
{ config, lib, pkgs, ... }:
let
  paths = ''
    export PATH="$HOME/.cabal/bin:$PATH"
    export PATH="$HOME/.cargo/bin:$PATH"
    export PATH="$HOME/.emacs.d/bin:$PATH"
    export PATH="$HOME/.local/bin:$PATH"
    export PATH="$HOME/bin:$PATH"
    export PATH="/usr/local/bin:$PATH"
  '';
in
{
  ".zshrc".text = ''
    # export NIX_PATH=$HOME/.nix-defexpr/channels''${NIX_PATH:+:}$NIX_PATH

    # authtenticates bitwarden for this shell session only
    bwAuth () { export BW_SESSION=`bw unlock --raw`; }

    ${paths}

    if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then
      . $HOME/.nix-profile/etc/profile.d/nix.sh;
    fi # added by Nix installer
  '';

  ".ghci".text = ''
    :set -XOverloadedStrings

    -- Read GHCI commands from the file whose name is
    -- in the GHCIRC environment variable
    -- :def _load const(System.Environment.getEnvironment >>= maybe (return "") readFile . lookup "GHCIRC")
    -- :_load
    -- :undef _load
  '';

  ".bash_profile".text = ''
    export EDITOR=emacsclient
    export GIT_EDITOR=$EDITOR

    alias lock=/System/Library/Frameworks/ScreenSaver.framework/Versions/Current/Resources/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine

    ${paths}

    export LANG=en_US.UTF-8

    shopt -s extglob

    export HISTCONTROL=erasedups
    export HISTSIZE=10000
    shopt -s histappend

    do_command_done_alert() {
        osascript -e 'display dialog "Command Done!"'
    }

    alert_when_done() {
        if test -n "$1";
        then
            while kill -0 $1
            do
                sleep 1
            done
        fi
        do_command_done_alert
    }

    export NIX_PATH=$HOME/.nix-defexpr/channels\$\{NIX_PATH:+:}$NIX_PATH

    if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then
      . $HOME/.nix-profile/etc/profile.d/nix.sh;
    fi # added by Nix installer
  '';

  ".bashrc".text = ''
    source ~/.bash_profile
  '';
}
#+end_src
** The full home.nix file
#+begin_src nix :tangle ./home.nix :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
ctx:
let
  <<load-niv>>
  this-machine = import ./this-machine.nix;
  dotfiles = (import ./dotfiles.nix) ctx2;
  emacs = (import ./emacs.nix) ctx2;
in
{
  # Let Home Manager install and manage itself.
  programs.home-manager.enable = true;

  # Home Manager needs a bit of information about you and the
  # paths it should manage.
  home.username = this-machine.username;
  home.homeDirectory = this-machine.homeDirectory;

  home.file = dotfiles // emacs.files;

  home.packages = [
    pkgs.awscli2 # aws/kubernetes cli access
    pkgs.ghcid
    pkgs.jq
    pkgs.jl
    pkgs.ispell
    emacs.doom-emacs
    pkgs.stack
    pkgs.bitwarden-cli
    # make this work; how??
    # want to be able to access the niv binary
    (import sources.niv {}).niv
  ] ++ emacs.packages;

  # This value determines the Home Manager release that your
  # configuration is compatible with. This helps avoid breakage
  # when a new Home Manager release introduces backwards
  # incompatible changes.
  #
  # You can update Home Manager without changing this value. See
  # the Home Manager release notes for a list of state version
  # changes in each release.
  home.stateVersion = "20.09";
}
#+end_src
* Utiliities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.

#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
* WIP Bitwarden and personal secrets
for now I am designing a script that will handle
working with various "private" information.

for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

the first thing I want to handle is restoring SSH keys to my local computer.
these can't be in git, and really they are essential for any meaningfully complete setup
For testing, i'd like to have a specific bitwarden acocunt with its own ssh key for gitlab
(issue/question? -- will I be able to disambiguate the keys? need to track this down. already had an issue with this at job),
a gitlab acct with a private repo just for this,
and then finally the test will run this checkout and ensure I am able to check it out
i would be able to store the bitwarden password in the test runner directly, at least as an env var. i am sure this must be a feature.

ideally i would have something like "restore from folder", and secret note names are like "file:~/.ssh/id_rsa_something", which
would then be "synced" to the local computer.

want to have a handy way to "add" files, say "add this file to the store" and then in the future would be able to restore/sync files

a "sync" command which will pull down those files, ideally telling me which ones will be updatied and giving an opp to confirm

* Nix darwin

running
darwin-rebuild switch -I darwin-config=$HOME/workstation/darwin-configuration.nix

building
nix-build https://github.com/LnL7/nix-darwin/archive/master.tar.gz -A installer
./result/bin/darwin-installer

# TODO ensure this ends up getting all tested on CI

#+begin_src sh :tangle ./darwin-configuration.nix :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
ctx@{ config, pkgs, ... }:
let
  this-machine = import ./this-machine.nix;
  hm = (import ./home.nix);
in
{
  imports = [ <home-manager/nix-darwin> ];

  # List packages installed in system profile. To search by name, run:
  # $ nix-env -qaP | grep wget
  environment.systemPackages =
    [
      pkgs.lorri
    ];

  environment.darwinConfig = "$HOME/workstation/darwin-configuration.nix";
  # copied from: https://github.com/target/lorri/issues/96#issuecomment-579931485
  # XXX: Copied verbatim from https://github.com/iknow/nix-channel/blob/7bf3584e0bef531836050b60a9bbd29024a1af81/darwin-modules/lorri.nix
  launchd.user.agents = {
    "lorri" = {
      serviceConfig = {
        WorkingDirectory = (builtins.getEnv "HOME");
        EnvironmentVariables = { };
        KeepAlive = true;
        RunAtLoad = true;
        StandardOutPath = "/var/tmp/lorri.log";
        StandardErrorPath = "/var/tmp/lorri.log";
      };
      script = ''
        source ${config.system.build.setEnvironment}
        exec ${pkgs.lorri}/bin/lorri daemon
      '';
    };
  };


  # Auto upgrade nix package and the daemon service.
  # services.nix-daemon.enable = true;
  # nix.package = pkgs.nix;

  # Create /etc/bashrc that loads the nix-darwin environment.
  programs.zsh.enable = true;  # default shell on catalina
  # programs.fish.enable = true;

  # Used for backwards compatibility, please read the changelog before changing.
  # $ darwin-rebuild changelog
  system.stateVersion = 4;
}
#+end_src
* Testing
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
#!/usr/bin/env bash
set -euox pipefail

# ensure all the references are set
source $HOME/.nix-profile/etc/profile.d/nix.sh

echo "RUNNING TESTS"

# emacs
if which emacs; then
    echo found emacs
    if which emacs | grep nix > /dev/null; then
        echo emacs installed by nix

        EMACS_VERSION=$(emacs -Q --batch --eval '(princ emacs-version)')
        if  [[ "$EMACS_VERSION" == "26.3" ]]; then
            echo emacs is correct version

            DOOM_VERSION=$(emacs --batch -l ~/.emacs.d/init.el --eval '(princ doom-version)')
            if  [[ "$DOOM_VERSION" == "2.0.9" ]]; then
                echo doom is correct version
            else
                echo doom is not reported to be correct version, found "$DOOM_VERSION"
                exit 1
            fi
        else
            echo emacs is not correct version, found $EMACS_VERSION
            exit 1
        fi
    else
        echo PROBLEM: emacs installed, but not installed by nix
        exit 1
    fi
else
  echo EMACS NOT FOUND
  exit 1
fi
#+end_src
** Github Actions CI
First, the CI config. Importantly, github CI support macos environments. Otherwise I
would be on GitLab instead.

#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

name: CI

on: [push]

jobs:
  build:
    runs-on: macos-10.15

    steps:
    - uses: actions/checkout@v2

    - name: Run a one-line script
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

bash link.sh

bash set-machine.sh gh-runner

bash install.sh

echo INSTALL PROCESS COMPLETE, TESTING

bash test/test.sh
#+end_src
* Future
** Tasks
*** STRT setup/test/evaluate bitwarden
create account *just* for CI server, authenticate against that
checkers/assertions about state of bitwarden

already added that shell function to automate unlocking bitwarden, but need to
consider additional steps

document logging in/out/setup, usage

could I write a little pbcopy/pbpaste routine that lets me quickly move the auth
from one shell to another?

*** TODO convert test script to haskell (try using a stack script)
*** TODO add a non-mac system on github (using built matrix?) to test if it works
*** TODO consider not installing master home-manager, instead installing specific revision
*** TODO move over any additional dotfiles needed, and delete repo if no longer has anything worthwhile
*** TODO set up rclone
*** TODO backup everything from my personal macbook air and then rebuild machine
*** TODO see if I can delete the Niv installation step
*** TODO investigate if its possible to prevent committing manually-edited target files (maybe with checksum and git pre-commit-hook?)
*** TODO add links for anyone interested/personal reference
**** nix
**** home manager
**** org mode
**** literate org
*** DONE org babel tangleify everything important
*** DONE lock down versions with niv
*** DONE figure out if any of the issues w/ CI are avoidable
*** DONE try this instead https://github.com/vlaci/nix-doom-emacs
