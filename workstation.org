#+TITLE: Workstation
* Background & Introduction
This is my workstation configuration. I have had a few different setups over the
years, so  this one is still a bit of a
work in progress. Honestly, accomplishing this is a lot harder than I expected.

I have no idea if anyone will ever read this, but from personal experience,
these workstation projects are easy to put aside for a long time, and then you
come back and can't remember how things were built.

So, this project is mostly written with literate
org mode. This gives me an easy way to document my thoughts as I work, and also
explore using ~org-mode~ for this task. I did this same thing a long time ago
with my old dotfiles setup, and I liked it, but everything else about it was a
massive pain, so it was eventually abandoned. If you want to see how this works,
you should view this file raw. When github renders org mode source blocks, it
omits all the headers.

Anyway, if you have any questions, feel free to shoot me an email or open an issue.

This same repo/setup *was* based upon ~nix~, but I had to abandon it. I still want
to go back to it, eventually. Most of the notes below which mention ~nix~ are
wrong/out of date, and I need to get around to updating them.

I kept that version with nix around in a branch, for my own future reference:
https://github.com/joelmccracken/workstation/tree/upgrade-org-with-nix-doom-emacs

I'd like to incorporate nix back into my workstation configuration, but I am not
ready for that yet.
* README
Every code project needs a README. This really just contains super simple instructions along with a link to this file, which
contains all the important information.

#+begin_src md :tangle ./README.md  :noweb yes
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. download the bootstrap shell script:
`curl https://raw.githubusercontent.com/joelmccracken/workstation/master/bin/bootstrap-workstation.sh > bootstrap-workstation.sh`
2. run `bash bootstrap-workstation.sh`
3. Profit!

# More Information

For more information, you should really read the <a href="workstation.org">workstation.org</a> file.
#+end_src
* Makefile
The first command is used to tangle ~workstation.org~. Tangling refers to the
process of  taking a literate program source and converting it to the target
"source" file for execution

#+begin_src makefile :tangle ./Makefile  :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
all: tangle switch

tangle:
	emacs -q -l lib/emacs/tangle-file.el --batch --tangle

bundle:
	brew bundle

.PHONY: tangle bundle
#+end_src

And a little emacs lisp that goes with the tangle process:

#+begin_src emacs-lisp :tangle ./lib/emacs/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

;; WARNING: This file is managed by tangling workstation.org. Do not edit directly!
(add-to-list 'command-switch-alist '("--tangle" . do-tangle))

(defun do-tangle (arg)
  "Do the tangle. ARG is ignored."
  (find-file "workstation.org")
  (org-babel-tangle))

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
* Bootstrap process
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle ./bin/bootstrap-workstation.sh :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

if [ "$1" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$1"
fi

sudo bash -c '(xcodebuild -license accept; xcode-select --install) || exit 0'

# install homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/Brewfile > ~/Brewfile

# bundle has to happen here because git is required for next step
brew bundle

polite-git-checkout () {
    DIR=$1
    REPO=$2

    cd $DIR
    git init
    git remote add origin $REPO
    git fetch

    # wont work (it will have already been deleted from the index)
    git reset --mixed origin/master
    # This formulation of the checkout command seems to work most reliably
    git status -s | grep -E '^ D' | sed -E 's/^ D //' | xargs -n 1 -- git checkout
}

polite-git-checkout ~ https://github.com/joelmccracken/workstation.git

cd ~

if test -e ~/.emacs.d; then
  mv ~/.emacs.d ~/.emacs.d-$(date +"%s")
fi

git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d

# If I ever have issues w/ this, I can use this form:
# timeout 10m bash -c 'yes | ~/.emacs.d/bin/doom install' || exit 0
~/.emacs.d/bin/doom -y install

echo FINISHED INSTALLING DOOM

echo installing nix

sh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume
source $HOME/.nix-profile/etc/profile.d/nix.sh
#+end_src
* Utilities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.

#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
** turtle shell
I have experimented with using ghci and the turtle library to start making an interacive
shell for myself to use in day-to-day work. The advantage of such a thing
is that I get to "dog-food" my own experiences with haskell and shell scripting.

Actually making this work well is a bit of a hack though.
GHCI doesn't really
have a way to pass in a custom file of "commands" to initialize the shell
(that is, beyond what the GHCI file would be), and IIRC I am unable to provide
a GHCI file for a custom invocation (e.g. many tools have a standard loction where
the configuration is located but ALSO provides a way to specify an alternate config file, but it appears that GHCI does not)

I foudn this ghci snippet somewhere on the internet for it, which will look for an environment variable pointing to a new file and if present it will load it.

*** The .ghci file
#+begin_src haskell :tangle ./.ghci :noweb yes
-- GHCI config
-- first off I always want overloaded strings on anyway so I can just
-- have this run every time ghci starts
:set -XOverloadedStrings
import Prelude
-- Read GHCI commands from the file whose name is
-- in the GHCIRC environment variable
-- :def _load const(System.Environment.getEnvironment >>= maybe (return "") readFile . lookup "GHCIRC")
-- :_load
-- :undef _load
-- :module
#+END_SRC
** I... hmmm... need to finish this
turtle-shell-rc.hs
* WIP Bitwarden and personal secrets
for now I am designing a script that will handle
working with various "private" information.

for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

the first thing I want to handle is restoring SSH keys to my local computer.
these can't be in git, and really they are essential for any meaningfully complete setup
For testing, i'd like to have a specific bitwarden acocunt with its own ssh key for gitlab
(issue/question? -- will I be able to disambiguate the keys? need to track this down. already had an issue with this at job),
a gitlab acct with a private repo just for this,
and then finally the test will run this checkout and ensure I am able to check it out
i would be able to store the bitwarden password in the test runner directly, at least as an env var. i am sure this must be a feature.

ideally i would have something like "restore from folder", and secret note names are like "file:~/.ssh/id_rsa_something", which
would then be "synced" to the local computer.

want to have a handy way to "add" files, say "add this file to the store" and then in the future would be able to restore/sync files

a "sync" command which will pull down those files, ideally telling me which ones will be updatied and giving an opp to confirm
* Testing
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euox pipefail

echo "RUNNING TESTS"

# emacs
if which emacs; then
    echo found emacs
else
  echo EMACS NOT FOUND
  exit 1
fi

EMACS_VERSION=$(emacs -Q --batch --eval '(princ emacs-version)')
if  [[ "$EMACS_VERSION" == "27.2" ]]; then
    echo emacs is correct version
else
    echo emacs is not correct version, found $EMACS_VERSION
    exit 1
fi

DOOM_VERSION=$(emacs --batch -l ~/.emacs.d/init.el --eval '(princ doom-version)')
if  [[ "$DOOM_VERSION" == "3.0.0-alpha" ]]; then
    echo doom is correct version
else
    echo doom is not reported to be correct version, found "$DOOM_VERSION"
    exit 1
fi
#+end_src
** Github Actions CI
First, the CI config. Importantly, github CI support macos environments. Otherwise I
would be on GitLab instead.

#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

name: CI

on: [push]

jobs:
  build:
    runs-on: macos-10.15
    timeout-minutes: 45

    steps:
    - uses: actions/checkout@v2

    - name: Run a one-line script
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

# env # are there environment variables where I can get the commit sha?

cd ~

if [ "$GITHUB_SHA" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$GITHUB_SHA"
fi

curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/bin/bootstrap-workstation.sh > bootstrap-workstation.sh

echo BEGINNING INITIAL INSTALL

bash bootstrap-workstation.sh $WORKSTATION_BOOTSTRAP_COMMIT
# -bash bin/bootstrap-workstation.sh
echo INSTALL PROCESS COMPLETE, TESTING

bash test/test.sh
#+end_src
* Future
** Tasks
*** STRT setup/test/evaluate bitwarden
create account *just* for CI server, authenticate against that
checkers/assertions about state of bitwarden

already added that shell function to automate unlocking bitwarden, but need to
consider additional steps

document logging in/out/setup, usage

could I write a little pbcopy/pbpaste routine that lets me quickly move the auth
from one shell to another?
*** TODO convert test script to haskell (try using a stack script)
*** TODO add a non-mac system on github (using built matrix?) to test if it works
*** TODO set up rclone
*** TODO backup everything from my personal macbook air and then rebuild machine
*** TODO investigate if its possible to prevent committing manually-edited target files (maybe with checksum and git pre-commit-hook?)
