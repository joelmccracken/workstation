#+PROPERTY: header-args    :comments noweb
#+OPTIONS: ^:nil ;; let an underscore be an underscore, disable sub-superscripting
#+OPTIONS: timestamp:nil
#+TITLE: Workstation
* Introduction: A Repeatable Workstation Configuration
This is my workstation configuration.

By default, our workstations are a hodge-podge of tweaks that accumulate
over the years. Quite often files etc are left over from old software we use.
Worse, files will be left over from old *versions* of software that we still
use. This makes it very confusing to tell what is essential and what is disjecta
membra.

This is my attempt to fix all that for myself, and perhaps you, dear reader.
If you have any questions, feel free to shoot me an email or open an issue.

** Rationale: The Problem
Have you ever had a tool or setup break and had a devil of a time trying to get
it back to a working state? This has happenend to me frequently.

Over the years, I've set up many new tools to help me with my work. But, time passes,
and things break. Sometimes I don't even notice they've broken for a long time,
so its even harder to fix. Something must have change must have changed: a
dependency, perhaps? or filesystem contents?
Or, even, perhaps I've forgotten how it is supposed to work.

This has been tricky to resolve. Especially if the tool is a hack I put
together.

To reach higher levels of productivty, it is essential to research,
develop, and use new tools for ourselves. Each of us has our own needs and
constraints.

So, I do not accept that this is just the way things have to be.

One final point: I've noticed over the years that there is a subtle pressure to
not install new things because I *know* it will cause a problem for me in the
future. But I think this is an anti-pattern, and needs to be fought against!
** Design choices
*** Requirements
*** invariants checking
generally we want to check that the computer satisfies our requirements.
This might mean anything from "user can successfully use sudo" to "I can compile
haskell source files".

this can also  be an early warning system, telling us that we need to do
something before it becomes an emergency.

Basically, this can take shape as a script I run regularly, but more ideally it
would (also) be something that is automatically run and have information
reported to me.
*** early problem reporting
we'd like to know about problems asap. If a new update comes out, and our whole
setup proces is flawed somehow with this system.
*** A note on Nix
In my circle, Nix is commonly used. So one may ask "why not do all this with
Nix"?

Nix has a "my way or the highway" philosophy. In fact, as far as I can
tell, it really doesn't provide any good way to:

- set up non-nix software
- provision ssh keys, secrets files, etc
- download and set up file system shares

Of course, I am still learning Nix, and I am sure this isn't totally 100% right,
its just my impressions. But the point is that I need some kind of "extra" setup
stuff anyway which needs to be independent of nix *anyway*.

This may change, but for now I'm just using nix sparingly, where it
makes sense, and doing everything else without it.
* Background and History
I have had a few different setups over the
years. Accomplishing this is a lot harder than I expected.
** Nix
This same repo/setup *was* based upon ~nix~, but I had to abandon it. I still want
to go back to it, eventually. Most of the notes below which mention ~nix~ are
wrong/out of date, and I need to get around to updating them.

I kept that version with nix around in a branch, for my own future reference:
https://github.com/joelmccracken/workstation/tree/upgrade-org-with-nix-doom-emacs

I'd like to incorporate nix back into my workstation configuration, but I am not
ready for that yet. I do install nix because I use it for scripting purposes,
but its not used to set up the majority of this system.
** Literate Programming
In my experience, these workstation projects are easy to put aside for a long
time, and when you come back you can't remember how things were built.

So, this project is mostly written with literate
org mode. This gives me an easy way to document my thoughts as I work, and also
explore using ~org-mode~ for this task. I did this same thing a long time ago
with my old dotfiles setup, and I liked it, but everything else about it was a
massive pain, so it was eventually abandoned. If you want to see how this works,
you should view this file raw. When github renders org mode source blocks, it
omits all the headers.
* README
Every project needs a README.
This really just contains super simple instructions along with a link to this file, which
contains all the important information.

#+begin_src md :tangle ./README.md  :noweb yes
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. download the bootstrap shell script:
`curl https://raw.githubusercontent.com/joelmccracken/workstation/master/bin/bootstrap-workstation.sh > bootstrap-workstation.sh`
2. run `bash bootstrap-workstation.sh`
3. Profit!
4. See workstation.org for manual setup documentation
# More Information

For more information, you should really read the <a href="workstation.org">workstation.org</a> file.
#+end_src
* Manual installation and setup
There are unfortunately a number of things I need to install and set up
manually:
- lastpass firefox extension
- vimium-ff etension
- dropbox
- icloud
- slack
- spotify
- install haskell language server in ~/bin (or somwewhere else?) for hls
- set ~/secrets/bw_pass
- bww force sync script

These are the settings I use for slack:
- accessibility then at bottom changbe up arrow to move focus to last message
- advanced
  - when in ```  enter should do a newline
  - format messages with markup

mac settings
- enable screen sharing, _not_ remote management
- enable remote login
* Makefile
The first command is used to tangle ~workstation.org~. Tangling refers to the
process of  taking a literate program source and converting it to the target
"source" file for execution

#+begin_src makefile :tangle ./Makefile  :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
all: tangle bundle

tangle:
	emacs -q -l lib/emacs/tangle-file.el --batch --tangle

bundle:
	cd ~
	brew bundle

.PHONY: tangle bundle
#+end_src

And a little emacs lisp that goes with the tangle process:

#+begin_src emacs-lisp :tangle ./lib/emacs/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

;; WARNING: This file is managed by tangling workstation.org. Do not edit directly!
(add-to-list 'command-switch-alist '("--tangle" . do-tangle))

(defun do-tangle (arg)
  "Do the tangle. ARG is ignored."
  (find-file "workstation.org")
  (org-babel-tangle))

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
* Bootstrap process
Bootstrapping is tricky. What do you actually start with? What can you assume?
You want to keep the amount of manual steps which need to occur to a minimum.
To my mind, this starts with a shell script.
This script could either do the entire setup process, or
theoretically it could also prepare the way for another process.

For me, I currently basically have a single bash script. But what I want to do
soon is change this so that its a bash script which invokes a haskell process asap.
so the bash script would basically do the minimum amount required to set up
everything for the haskell process.

** Remaining Tasks
*** TODO set up ubuntu version CI process
*** TODO set up ubuntu version of bootstrap
seprate script, or script that is smart enough run on mac and linux?
mac
- setup/install/check xcode (needed for brew)
- install homebrew (needed for bundle/git (maybe?))
- brew install git
- git init.. clone... etc polite checkout
- brew bundle (needed for git (actually does xcode-select get this for me?))
- setup/install/check doom
- setup/install/check nix
- setup/install/check haskell stack
ubuntu
- apt-get update/check
- apt-get install/check all the things
common
- build bww however it needs to be built
*** TODO figure out how to get bww sync to happen automatically
*** TODO fix origins for workstation repo and dotfiles
*** TODO move most of the setup process to haskell
shell script should just download workstation repo, install stack, build haskell
code, then invoke built setup process
*** TODO echo instructions on what to do once bootstraip is done
need to enter ~/secrets/bw_pass file
*** TODO establish/determine "phases" to setup
initial bootstrap (checkout files, setup haskell, etc)
pre-authentication (pre-bww sync)
using haskell to do remaining setup
** Code
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle ./bootstrap-workstation.sh :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

if [ "$1" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$1"
fi

WS_DIR="$HOME/workstation"

# TODO should be naturally idempontent
sudo bash -c '(xcodebuild -license accept; xcode-select --install) || exit 0'

# TODO first check to see if brew is installed
# install homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# install git, necessary for next step
# TODO this should be safe to run even if its been run before
brew install git

polite-git-checkout () {
    DIR=$1
    REPO=$2

    cd $DIR
    git init
    git remote add origin $REPO
    git fetch

    # wont work (it will have already been deleted from the index)
    git reset --mixed origin/master
    # This formulation of the checkout command seems to work most reliably
    git status -s | grep -E '^ D' | sed -E 's/^ D //' | xargs -n 1 -- git checkout
}

function mv_dir_dated_backup() {
    local THEDIR="$1"
    if test -e "$THEDIR"; then
        mv "$THEDIR" "${THEDIR}-$(date +"%s")"
    fi
}

cd ~

# TODO first check to see if origin etc is correct?
polite-git-checkout ~ https://github.com/joelmccracken/dotfiles.git

brew bundle

# TODO check first to see if the desired contents have correct git
#      remote for origin etc. Can manually fix if this check is not right
mv_dir_dated_backup ~/workstation
git clone https://github.com/joelmccracken/workstation.git

# TODO is there some way to see if doom is already installed??
mv_dir_dated_backup ~/.emacs.d
git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d

# If I ever have issues w/ this, I can use this form:
# timeout 10m bash -c 'yes | ~/.emacs.d/bin/doom install' || exit 0
~/.emacs.d/bin/doom -y install

echo FINISHED INSTALLING DOOM

echo installing nix

# TODO see if nix is already installed
sh <(curl -L https://nixos.org/nix/install)

NIX_DAEMON_PATH='/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'

if [ -e "$NIX_DAEMON_PATH" ]; then
  (source "$NIX_DAEMON_PATH") || exit 0
fi

# TODO if stack is already installed, dont run this
curl -sSL https://get.haskellstack.org/ | sh
#+end_src
* Post-bootstrap setup
* System update process
- fetch ~/worksation and ~, if can clealy rebase, do so
- run any other kind of "sync"
* System "check"
need to have a "check that system is OK"
** TODO make check for updates on remote of ~ and ~workstation
** TODO make check for nix (~nix store verify --all~ and ~nix-doctor~)
** TODO make check for brew
** TODO make check that no new secrets need to be synced
** TODO make check that reddup is good
** TODO make check for various execuables I care about
* Utilities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.

#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
* Bitwarden and personal secrets
I have a script to set up and download various "private" information.
for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

This restores SSH keys to my local computer.
These can't be in git, and really they are essential for any meaningfully
complete workstation setup.
** TODO move the bww stuff into this section of workstation
** TODO set up a testing account on bitwarden for CI/testing
** TODO set up a "check" command which shows what would change if a sync happened
* Machine profiles
** TODO set up machine-specific settings profiles
E.g. ~/workstation/profiles
*** glamdring/
*** anduril/
*** aeglos/
*** ci/
* Testing
** TODO convert all this testing to haskell
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euox pipefail

function assert_input() {
  local label=$1
  local expected=$2
  local actual
  read actual

  if [[ "$expected" == "$actual" ]]; then
    echo "$label is correct"
  else
    echo "$label is not correct, found '$actual', expected '$expected'"
    exit 1
  fi
}

echo "RUNNING TESTS"

# emacs
if which emacs; then
    echo found emacs
else
  echo EMACS NOT FOUND
  exit 1
fi

emacs -Q --batch --eval '(progn (princ emacs-version) (terpri))' | assert_input "emacs version" '27.2'
emacs --batch -l ~/.emacs.d/init.el --eval '(progn (princ doom-version) (terpri))' | assert_input "doom-version" '21.12.0-alpha'
emacs --batch -l ~/.emacs.d/init.el --eval '(progn (princ doom-core-version) (terpri))' | assert_input "doom-core-version" '3.0.0-alpha'

echo "TESTS COMPLETE"
#+end_src
** Github Actions CI
First, the CI config. Importantly, github CI support macos environments. Otherwise I
would be on GitLab instead.

#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

name: CI

on:
  push:
  schedule:
  - cron: '0 0 * * *'  # every day at midnight

jobs:
  build:
    runs-on: macos-10.15
    timeout-minutes: 45

    steps:
    - uses: actions/checkout@v2

    - name: Run a one-line script
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

# env # are there environment variables where I can get the commit sha?

cd ~

if [ "$GITHUB_SHA" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$GITHUB_SHA"
fi

curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/bootstrap-workstation.sh > bootstrap-workstation.sh

echo BEGINNING INITIAL INSTALL

bash bootstrap-workstation.sh $WORKSTATION_BOOTSTRAP_COMMIT
echo INSTALL PROCESS COMPLETE, TESTING

bash ~/workstation/test/test.sh
#+end_src
* Operational/maintenance
** TODO rebuild my personal laptop once all of this is stable
* Misc
** TODO investigate if its possible to prevent committing manually-edited target files (maybe with checksum and git pre-commit-hook?)
