#+PROPERTY: header-args    :comments both
#+OPTIONS: ^:nil ;; let an underscore be an underscore, disable sub-superscripting
#+OPTIONS: timestamp:nil
#+TITLE: Workstation
* Introduction: A Repeatable Workstation Configuration
This is my workstation configuration.

By default, our workstations are a hodge-podge of tweaks that accumulate
over the years. Quite often files etc are left over from old software we use.
Worse, files will be left over from old *versions* of software that we still
use. This makes it very confusing to tell what is essential and what is disjecta
membra.

This is my attempt to fix all that for myself, and perhaps you, dear reader.
If you have any questions, feel free to shoot me an email or open an issue.

** Rationale: The Problem
Have you ever had a tool or setup break and had a devil of a time trying to get
it back to a working state? This has happenend to me frequently.

Over the years, I've set up many new tools to help me with my work. But, time passes,
and things break. Sometimes I don't even notice they've broken for a long time,
so its even harder to fix. Something must have change must have changed: a
dependency, perhaps? or filesystem contents?
Or, even, perhaps I've forgotten how it is supposed to work.

This has been tricky to resolve. Especially if the tool is a hack I put
together.

To reach higher levels of productivty, it is essential to research,
develop, and use new tools for ourselves. Each of us has our own needs and
constraints.

So, I do not accept that this is just the way things have to be.

One final point: I've noticed over the years that there is a subtle pressure to
not install new things because I *know* it will cause a problem for me in the
future. But I think this is an anti-pattern, and needs to be fought against!
** Design choices
*** Requirements
*** invariants checking
generally we want to check that the computer satisfies our requirements.
This might mean anything from "user can successfully use sudo" to "I can compile
haskell source files".

this can also  be an early warning system, telling us that we need to do
something before it becomes an emergency.

Basically, this can take shape as a script I run regularly, but more ideally it
would (also) be something that is automatically run and have information
reported to me.
*** early problem reporting
we'd like to know about problems asap. If a new update comes out, and our whole
setup proces is flawed somehow with this system.
* Background and History
I have had a few different setups over the
years. Accomplishing this is a lot harder than I expected.
** Literate Programming
In my experience, these workstation projects are easy to put aside for a long
time, and when you come back you can't remember how things were built.

So, this project is mostly written with literate
org mode. This gives me an easy way to document my thoughts as I work, and also
explore using ~org-mode~ for this task. I did this same thing a long time ago
with my old dotfiles setup, and I liked it, but everything else about it was a
massive pain, so it was eventually abandoned. If you want to see how this works,
you should view this file raw.
* README
#+begin_src md :tangle ./README.md  :noweb yes
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. download the bootstrap shell script:
`curl https://raw.githubusercontent.com/joelmccracken/workstation/master/bin/bootstrap-workstation.sh > bootstrap-workstation.sh`
2. run `bash bootstrap-workstation.sh MACHINE_NAME BRANCH
3. Profit!
4. See workstation.org for manual setup documentation;
# More Information

You should really read the file
<a href="workstation.org">workstation.org</a>.
#+end_src
* Manual installation and setup
There are unfortunately a number of things I need to install and set up
manually:
- lastpass firefox extension
- vimium-ff etension
- dropbox
- icloud
- slack
- spotify
- install haskell language server in ~/bin (or somwewhere else?) for hls
- set ~/secrets/bw_pass
- bww force sync script

These are the settings I use for slack:
- accessibility then at bottom changbe up arrow to move focus to last message
- advanced
  - when in ```  enter should do a newline
  - format messages with markup

mac settings
- enable screen sharing, _not_ remote management
- enable remote login
* Makefile
Used to tangle ~workstation.org~. Tangling refers to the
process of taking a literate program source and converting it to the target
"source" file for execution.

Formerly had some other targets, but now they are OBE. It may make sense to
delete this makefile if it becomes clearly unnecessary.
#+begin_src makefile :tangle ./Makefile  :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
all: tangle

tangle:
	emacs -l ~/.emacs.d/init.el -l lib/emacs/tangle-file.el --batch --tangle

.PHONY: tangle
#+end_src
And a little emacs lisp that goes with the tangle process:
#+begin_src emacs-lisp :tangle ./lib/emacs/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

;; WARNING: This file is managed by tangling workstation.org. Do not edit directly!
(add-to-list 'command-switch-alist '("--tangle" . do-tangle))

(defun do-tangle (arg)
  "Do the tangle. ARG is ignored."
  (find-file "workstation.org")
  (org-babel-tangle))

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
** TODO move bin/tangle script into workstation.org
* Bootstrap process
Bootstrapping is tricky. What do you actually start with? What can you assume?
You want to keep the amount of manual steps which need to occur to a minimum.
To my mind, this starts with a shell script.
This script could either do the entire setup process, or
theoretically it could also prepare the way for another process.

For me, I currently basically have a single bash script. But what I want to do
soon is change this so that its a bash script which invokes a haskell process asap.
so the bash script would basically do the minimum amount required to set up
everything for the haskell process.

** Remaining Tasks
*** TODO figure out how to get bww sync to happen automatically
*** TODO fix origins for workstation repo and dotfiles
*** TODO port test/test.sh into wshs/haskell
*** TODO look into using home manager/nix again for emacs
the main thought here is that its becoming clear that I want to have at lest the
option to build emacs with my own options (specifically, xwidget webkit support)
or perhaps using one of the other projects I ha
*** TODO use home manager for macos, ubuntu, nixos
*** TODO echo instructions on what to do once bootstraip is done
need to enter ~/secrets/bw_pass file, then prep that
*** TODO establish/determine "phases" to setup
initial bootstrap (checkout files, setup haskell, etc)
pre-authentication (pre-bww sync)
using haskell to do remaining setup
** Bootstraping Script
This script is intended to be entrypoint to this project. It can be curled to a
new machine and then run, and will set things up on that machine as necessary.
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle ./bootstrap-workstation.sh :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

if [ -z "${1+x}" ]; then
    echo WORKSTATION_NAME must be provided as first argument
    exit 2
else
    WORKSTATION_NAME="$1"
fi

if [ -z "${2+x}" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$2"
fi

WS_DIR="$HOME/workstation"

function is_mac() {
    [[ "$(uname)" == 'Darwin' ]]
}

function is_linux() {
    [[ "$(uname)" == 'Linux' ]]
}

is_mac && {
    sudo bash -c '(xcodebuild -license accept; xcode-select --install) || exit 0'

    which brew > /dev/null || {
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

        # install git, necessary for next step
        # TODO this should be safe to run even if its been run before
        brew install git
    }
}

is_linux && {
    sudo bash -c 'apt-get update && apt-get install git'
}

polite-git-checkout () {
    DIR=$1
    REPO=$2

    cd $DIR
    git init
    git remote add origin $REPO
    git fetch

    # wont work (it will have already been deleted from the index)
    git reset --mixed origin/master
    # This formulation of the checkout command seems to work most reliably
    git status -s | grep -E '^ D' | sed -E 's/^ D //' | xargs -n 1 -- git checkout
}

function mv_dir_dated_backup() {
    local THEDIR="$1"
    if test -e "$THEDIR"; then
        mv "$THEDIR" "${THEDIR}-$(date +"%s")"
    fi
}

{
    cd ~;
    [[ "$(git remote get-url origin)" == 'git@github.com:joelmccracken/dotfiles.git' ]]
} || polite-git-checkout ~ 'https://github.com/joelmccracken/dotfiles.git'

{
    cd ~/worksation;
    [[ "$(git remote get-url origin)" == 'git@github.com:joelmccracken/workstation.git' ]]
} || {
    mv_dir_dated_backup ~/workstation
    git clone 'https://github.com/joelmccracken/workstation.git'
}

echo installing nix

{ which nix > /dev/null; } || {
    sh <(curl -L https://releases.nixos.org/nix/nix-2.5.1/install) --daemon;
}

export NIX_REMOTE=daemon

( sudo bash -c 'mkdir -p /etc/nix; cat > /etc/nix/nix.conf') <<-EOF
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=
substituters = https://cache.nixos.org https://hydra.iohk.io
experimental-features = nix-command flakes
trusted-users = root joel runner
build-users-group = nixbld
# END OF /etc/nix/nix.conf
EOF

cat /etc/nix/nix.conf

is_linux && {
    sudo systemctl restart nix-daemon.service;
}

is_mac && {
    set +e
    sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    sudo launchctl load /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    set -e
}

NIX_DAEMON_PATH='/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
cat $NIX_DAEMON_PATH
if [[ -e "$NIX_DAEMON_PATH" ]]; then
    set +u
    source "$NIX_DAEMON_PATH";
    set -u
fi;

cd  ~/workstation/propellor/
nix build .#propellor:exe:propellor-config
result/bin/propellor-config "$WORKSTATION_NAME";

# most of the stuff below this can be moved to propellor

is_linux && {
    sudo ~/workstation/bin/enable-passwordless-sudo.sh
    sudo apt-get update
    sudo snap install emacs --classic
    sudo apt-get install ripgrep fd-find zsh make libtool libvterm-dev
}

{
    cd ~/.emacs.d;
    [[ "$(git remote get-url origin)" == 'https://github.com/hlissner/doom-emacs' ]]
} || {
    mv_dir_dated_backup ~/.emacs.d;
    git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d;
    # alternative: use this if encounter problems
    # ~/.emacs.d/bin/doom -y install;
    timeout 7m bash -c 'yes | ~/.emacs.d/bin/doom install' || exit 0
    echo FINISHED INSTALLING DOOM;
}
#+end_src
* Post-bootstrap setup
* System update process
- fetch ~/worksation and ~, if can clealy rebase, do so
- run any other kind of "sync"
* System "check"
need to have a "check that system is OK"
** TODO make check for updates on remote of ~ and ~workstation
** TODO make check for nix (~nix store verify --all~ and ~nix-doctor~)
** TODO make check for brew
** TODO make check that no new secrets need to be synced
** TODO make check that reddup is good
** TODO make check for various execuables I care about
* Utilities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.
#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
* Bitwarden and personal secrets
I have a script to set up and download various "private" information.
for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

This restores SSH keys to my local computer.
These can't be in git, and really they are essential for any meaningfully
complete workstation setup.
** TODO move the bww stuff into this section of workstation
** TODO set up a testing account on bitwarden for CI/testing
** TODO set up a "check" command which shows what would change if a sync happened
* Machine profiles
** TODO set up machine-specific settings profiles
E.g. ~/workstation/profiles
*** glamdring/
*** anduril/
*** aeglos/
*** ci/
* Testing
** TODO convert all this testing to haskell
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
set -euox pipefail

function assert_input() {
  local label=$1
  local expected=$2
  local actual
  read actual

  if [[ "$expected" == "$actual" ]]; then
    echo "$label is correct"
  else
    echo "$label is not correct, found '$actual', expected '$expected'"
    exit 1
  fi
}

echo "RUNNING TESTS"

# emacs
if which emacs; then
    echo found emacs
else
  echo EMACS NOT FOUND
  exit 1
fi

emacs -Q --batch --eval '(progn (princ emacs-version) (terpri))' | assert_input "emacs version" '27.2'
emacs --batch -l ~/.emacs.d/init.el --eval '(progn (princ doom-version) (terpri))' | assert_input "doom-version" '21.12.0-alpha'
emacs --batch -l ~/.emacs.d/init.el --eval '(progn (princ doom-core-version) (terpri))' | assert_input "doom-core-version" '3.0.0-alpha'

echo "TESTS COMPLETE"
#+end_src
** Github Actions CI
Importantly, github CI support macos environments.

Daily build to ensure that potential problems get caught (NB: I have had issues
where a working setup no longer worked due to bit rot, which would have been
caught with a regular build like this).

I am running up close to maximum execution time, so very likely I will need to
refactor/come up with some other way to do this.
#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!
name: CI

on:
  push:
  schedule:
  - cron: '0 0 * * *'  # every day at midnight

jobs:
  build:
    strategy:
      matrix:
        os:
        # - macos-10.15
        - macos-latest
        - ubuntu-latest
    runs-on: ${{ matrix.os }}
    timeout-minutes: 45
    steps:
    - uses: actions/checkout@v2

    - name: Run a one-line script
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes
# WARNING: This file is managed by tangling workstation.org. Do not edit directly!

set -xeuo pipefail

# env # are there environment variables where I can get the commit sha?

cd ~

if [ "$GITHUB_SHA" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$GITHUB_SHA"
fi

curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/bootstrap-workstation.sh > bootstrap-workstation.sh

echo BEGINNING INITIAL INSTALL

if [ "$RUNNER_OS" == "macOS" ]; then
    bash bootstrap-workstation.sh ci-macos $WORKSTATION_BOOTSTRAP_COMMIT
else
    bash bootstrap-workstation.sh ci-ubuntu $WORKSTATION_BOOTSTRAP_COMMIT
fi

echo INSTALL PROCESS COMPLETE, TESTING

bash ~/workstation/test/test.sh
#+end_src
* Operational/maintenance
** TODO rebuild my personal laptop once all of this is stable
* Misc
** TODO investigate if its possible to prevent committing manually-edited target files (maybe with checksum and git pre-commit-hook?)
* Quick note
#+begin_src sh
home-manager switch --flake .
#+end_src
