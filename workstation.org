#+PROPERTY: header-args :comments both :noweb yes
#+OPTIONS: ^:nil ;; let an underscore be an underscore, disable sub-superscripting
#+OPTIONS: timestamp:nil
#+TITLE: Workstation
* Introduction: A Repeatable Workstation Configuration
This is my workstation configuration.

By default, our workstations are a hodge-podge of tweaks that accumulate
over the years. Quite often files etc are left over from old software we use.
Worse, files will be left over from old *versions* of software that we still
use. This makes it very confusing to tell what is essential and what is disjecta
membra.

This is my attempt to fix all that for myself, and perhaps you, dear reader, may
find it of use as well. If you have any questions, feel free to shoot me an
email or open an issue (honestly, it would be somewhat nice to know that at
least *one* other person has read this).
** Rationale: The Problem
Have you ever had a tool or setup break and had a devil of a time trying to get
it back to a working state? Over the years, I've set up many new tools to help
me with my work. But, time passes,
and things break. Sometimes I don't even notice they've broken for a long time,
so its even harder to fix. Something must have change must have changed: a
dependency, perhaps? or filesystem contents?
Or, even, perhaps I've forgotten how it is supposed to work.

This has been tricky to resolve. Especially if the tool is a hack I put
together.

What is more, to reach higher levels of productivty, it is essential to research,
develop, and use new tools for ourselves. Each of us has our own needs and
constraints. However, without a firm foundation, these rube-goldberg development
approaches are very fragile.

So, I have been trying to do just this: provide myself a repeatable, executable
workstation setup which I can extend when needed and rely on if something
unforseen happens (e.g. laptop breaks).

One final point: I've noticed over the years that there is a subtle pressure to
not install new things because I *know* it will cause a problem for me in the
future. But I think this is an anti-pattern, and needs to be fought against!
** Design choices
*** Requirements
- open source
- hackable
- where reasonable, use repeatable, automatable solutions
*** Invariants checking
It is necessary to check that the computer satisfies stated requirements.
This might mean anything from "user can successfully use sudo" to "I can compile
haskell source files".

Basically, this can take shape as a script I run regularly, but more ideally it
would (also) be something that is automatically run and have information
reported to me.

Currently, the intention is that this will come in the form of running ~ws
check~, which is a part of the wshs sub-project in the wshs directory.
*** early problem reporting
Ideally, we'd like to know about problems asap. If a new update comes out, and
our whole setup proces is flawed somehow with the new update, it is important to
realize and address when I can.
* Background and History
I have had a few different setups over the
years. Accomplishing this is a lot harder than I expected.
** Literate Programming
In my experience, these workstation projects are easy to put aside for a long
time, and when you come back you can't remember how things were built.

So, this project is mostly written with literate
org mode. This gives me an easy way to document my thoughts as I work, and also
explore using ~org-mode~ for this task. I did this same thing a long time ago
with my old dotfiles setup, and I liked it, but everything else about it was a
massive pain, so it was eventually abandoned.

If you want to see how literate programming works in org mode, view this raw file.
* README
#+begin_src md :tangle ./README.md  :noweb yes :comments none
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. download the bootstrap shell script:
`curl https://raw.githubusercontent.com/joelmccracken/workstation/master/bin/bootstrap-workstation.sh > bootstrap-workstation.sh`
2. run `bash bootstrap-workstation.sh MACHINE_NAME BRANCH
3. Profit!
4. See workstation.org for manual setup documentation
# More Information

Much more information may be found in
<a href="workstation.org">workstation.org</a>.
#+end_src
* Makefile
Used to tangle ~workstation.org~. Tangling refers to the
process of taking a literate program source and converting it to the target
"source" file for execution.

Formerly had some other targets, but now they are OBE. It may make sense to
delete this makefile if it becomes clearly unnecessary.
#+begin_src makefile :tangle ./Makefile  :noweb yes
all: tangle

tangle:
	bash bin/tangle.sh

.PHONY: tangle
#+end_src

Which requires a shell script:

#+begin_src sh :shebang "#!/usr/bin/env bash" :tangle ./bin/tangle.sh
EMACS_CONFIG_DIR=~/.config/emacs;
$EMACS_CONFIG_DIR/bin/doomscript lib/emacs/tangle-file.el
#+end_src

And a little emacs lisp that goes with the tangle process:
#+begin_src emacs-lisp :tangle ./lib/emacs/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

(setq safe-local-variable-values
      '((org-babel-noweb-wrap-start . "«")
        (org-babel-noweb-wrap-end . "»")))

(doom-require 'doom-start)

(defun do-tangle ()
  "Do the tangle"
  (find-file "workstation.org")
  (org-babel-tangle))

(do-tangle)

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
* Bootstrap process
Bootstrapping is tricky. What do you actually start with? What can you assume?
You want to keep the amount of manual steps which need to occur to a minimum.
I start start with a shell script.
This script could either do the entire setup process, or
theoretically it could also prepare the way for another process.

For me, I currently basically have a single bash script. But what I want to do
soon is change this so that its a bash script which invokes a haskell process asap.
so the bash script would basically do the minimum amount required to set up
everything for the haskell process. This is still a work in progress, and since
this project is starting to stablize, I may abandon the haskell portion of the
setup.
** Bootstraping Script
This script is intended to be entrypoint to this project. It can be curled to a
new machine and then run, and will set things up on that machine as necessary.

The steps to the setup are given more details in
[[*Bootstrap Script Execution Process][Bootstrap Script Execution Process]].
#+begin_src sh :shebang "#!/usr/bin/env bash" :tangle ./bootstrap-workstation.sh :noweb yes

set -xeuo pipefail

«bootstrap-steps»

#+end_src
** Bootstrap Script Execution Process
:PROPERTIES:
:header-args: :noweb-ref bootstrap-steps :comments noweb
:ID:       74975286-5772-4094-8077-052d7eb35f14
:END:
This portion of the document explains the various execution steps of bootstrap.

Each of these steps are executed sequentially.
*** Set Version Settings
#+begin_src shell
# These are the various versions of things that should be installed. Keeping them
# in one place like this make them easier to keep track of.

export NIX_PM_VERSION=nix-2.11.1
export NIX_DARWIN_VERSION=f6648ca0698d1611d7eadfa72b122252b833f86c
export HOME_MANAGER_VERSION=0f4e5b4999fd6a42ece5da8a3a2439a50e48e486
#+end_src
*** Argument Parsing
#+begin_src shell
# Script should be passed a single argument, which is name of this workstation.

# When using script to set up a workstation, the "name" of the workstation should
# be provided as the first argument. This is used to pick which settings should be
# applied to this machine.
if [ -z "${1+x}" ]; then
    echo WORKSTATION_NAME must be provided as first argument
    exit 2
else
    export WORKSTATION_NAME="$1"
fi

# This argument generally should not be used by the user, but it is needed for
# the CI process.
# When the CI process starts, we start out with a check out of the code for this
# commit in a directory on the CI machine. However, this is not how workstation runs:
# - part of the job of workstation is getting its own code from the server
# - workstation expects the code to be in a specific directory, that is, ~/workstation
# Because of this (and possibly other reasons that escape me now), even though the
# source code of the current commit is checked out on the CI machine already,
# the CI process re-downloads the code (via this script). The specific SHA to get
# is passed via the argument below. However, if actually being used by a user,
# generally user will always want to use the most up to date content of the master
# branch, so this can be ignored.
# I think probably this sha should just be passed in as an environment variable
# instead of a CLI argument, as that seems a bit less confusing to me.
if [ -z "${2+x}" ]; then
    export WORKSTATION_BOOTSTRAP_COMMIT=origin/master
else
    export WORKSTATION_BOOTSTRAP_COMMIT="$2"
fi
#+end_src
*** Setting some variables to keep things DRY
#+begin_src shell
# having these variables here really just makes the code a bit more DRY
WS_DIR="$HOME/workstation"
export WORKSTATION_HOST_SETTINGS_SRC_DIR=$WS_DIR/hosts/$WORKSTATION_NAME
export WORKSTATION_HOST_CURRENT_SETTINGS_DIR=$WS_DIR/hosts/current
WS_ORIGIN='git@github.com:joelmccracken/workstation.git'
WS_ORIGIN_PUB='https://github.com/joelmccracken/workstation.git'
EMACS_CONFIG_DIR=~/.config/emacs
#+end_src
*** Helper Functions
#+begin_src shell :noweb yes
# hereafter, we use many helper functions. Here they are defined up front,
# as some of them are used throughout the other code.

«is_mac_function»

«is_linux_function»

«info_function»

«polite_git_checkout_function»

«mv_dated_backup_function»

«is_git_repo_cloned_at_function»

«clone_repo_and_checkout_at_function»

«xcode_setup_function»

«is_brew_installed_function»

«homebrew_setup_function»

«update_apt_install_git_function»

«is_git_repo_cloned_at_function»

«clone_repo_and_checkout_at_function»

«install_doom_emacs_no_nix_function»
#+end_src
*** Log that bootstrap is starting
#+begin_src shell
info starting workstation bootstrap
#+end_src
*** macos only: ensure xcode, homebrew, and git are ready to go
#+begin_src shell :noweb yes
is_mac && {
    info ensuring xcode is installed
    xcode_setup
    info finished ensuring xcode is installed

    info ensuring brew is installed
    if ! is_brew_installed; then
        homebrew_setup
    fi
    info finished ensuring brew is installed

    info installing git
    brew install git
    info finished installing git

}
#+end_src
*** (ubuntu) linux only: update apt and install git
#+begin_src shell :noweb yes
is_linux && {
    info updating apt, installing git
    update_apt_install_git
    info finished updating apt, installing git
}
#+end_src
*** check out correct workstation commit
#+begin_src shell :noweb yes
is_git_repo_cloned_at $WS_DIR $WS_ORIGIN || {
    clone_repo_and_checkout_at $WS_DIR $WS_ORIGIN_PUB \
        $WORKSTATION_BOOTSTRAP_COMMIT
}
#+end_src
*** check out the dotfiles repository
#+begin_src shell :noweb yes
# at this point, this is hardly necessary; however, the gitignore file is handy
# i may explore getting rid of this repo entirely and just having a fresh
# repo without any origin in ~
info ensuring dotfiles repo is checked out

is_git_repo_cloned_at ~ 'git@github.com:joelmccracken/dotfiles.git' ||
    polite-git-checkout ~ 'https://github.com/joelmccracken/dotfiles.git'

info finished ensuring dotfiles repo is checked out

info linking dotfiles that should be symlinked
bash ~/workstation/bin/link-dotfiles.sh -f
info finished linking dotfiles
#+end_src
*** set up host specific settings
#+begin_src shell :noweb yes
# each workstaion host I use has different settings needs.
# For example, my remote cloud hosted server has a different setup than
# my mac laptop, which has a different set up from my work computer.
# the way I have these settings specified is by having a directory in my home
# directory which has all of the needed files I would need for such differences.
# there are different directories for each host I maintain, but on a given host,
# one of those directories are symlinked into 'current' host, which other things
# can then refer to

info setting current host settings directory...
info workstation host settings directory: $WORKSTATION_HOST_SETTINGS_SRC_DIR

if [ -d $WORKSTATION_HOST_SETTINGS_SRC_DIR ]; then
    info setting current host directory to $WORKSTATION_HOST_SETTINGS_SRC_DIR;
    ln -s $WORKSTATION_HOST_SETTINGS_SRC_DIR $WORKSTATION_HOST_CURRENT_SETTINGS_DIR;
else
    echo ERROR $WORKSTATION_HOST_SETTINGS_SRC_DIR does not exist, must exit
    exit 5
fi
#+end_src
*** rest of the script
#+begin_src shell :noweb yes
info ensuring nix is installed
{ which nix > /dev/null; } || {
    info installing nix
    sh <(curl -L https://releases.nixos.org/nix/$NIX_PM_VERSION/install) --daemon;
}
info finished ensuring nix is installed

export NIX_REMOTE=daemon

info setting up nix.conf
(sudo bash -c 'mkdir -p /etc/nix; cat > /etc/nix/nix.conf') <<-EOF
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=
substituters = https://cache.nixos.org https://cache.iog.io
experimental-features = nix-command flakes
trusted-users = root $(whoami) runner
build-users-group = nixbld
# END OF /etc/nix/nix.conf
EOF


function restart_linux_daemon() {
    sudo systemctl restart nix-daemon.service;
}

function restart_mac_daemon() {
    set +e
    sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    sudo launchctl load /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    set -e
}

is_mac && {
    info macos detected, restarting nix-daemon
    restart_mac_daemon
    info finished restarting nix-daemon
}

is_linux && {
    info restarting nix-daemon via systemctl
    restart_linux_daemon
    info finished restarting nix-daemon via systemctl
}

NIX_DAEMON_PATH='/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
cat $NIX_DAEMON_PATH
if [[ -e "$NIX_DAEMON_PATH" ]]; then
    set +u
    source "$NIX_DAEMON_PATH";
    set -u
fi;

is_linux && {
    sudo ~/workstation/bin/enable-passwordless-sudo.sh
    sudo apt-get update
}

«nix_darwin_rebuild_flake_function»

is_mac && {
    info installing darwin-nix
    cd $WS_DIR
    nix-build https://github.com/LnL7/nix-darwin/archive/${NIX_DARWIN_VERSION}.tar.gz -A installer
    ./result/bin/darwin-installer

    nix_darwin_rebuild_flake

    info finished installing darwin-nix
}

export NIX_PATH=""
export HOME_MANAGER_BACKUP_EXT=old

nix run home-manager/$HOME_MANAGER_VERSION -- init ~/workstation

«home_manager_flake_switch_function»
home_manager_flake_switch

set +u
# evaluating this with set -u will cause an unbound variable error
source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
set -u

install_doom_emacs_no_nix

echo "building the 'ws' script"
cd  ~/workstation/wshs
nix build --no-link -L .#"wshs:exe:bww" .#"wshs:exe:ws"
echo "running the 'ws install' process"
$(nix path-info .#"wshs:exe:ws")/bin/ws install -m "$WORKSTATION_NAME";
echo "'ws install' process completed"

set +e
echo "Running final installs (install)"
if is_linux; then
    echo "is linux, installing ripgrep, fdfind, etc via apt";
    time sudo apt-get install ripgrep fd-find zsh make libtool libvterm-dev;
    echo "done running final installs";
else
    echo "linux not detected, no final installs necessary";
fi

# why is bash so cryptic
if [ ! -z "${BW_CLIENTID+x}" ] && \
   [ ! -z "${BW_CLIENTSECRET+x}" ] && \
   [ ! -z "${WS_BW_MASTER_PASS+x}" ]; then
    info variables requried to run bww force-sync are set, running
    if [ ! -d ~/secrets ]; then
        mkdir ~/secrets;
    fi
    # overwriting anything that was previously in the file
    echo "${WS_BW_MASTER_PASS}" > ~/secrets/bw_pass
    bw login --apikey
    bw_unlock
    bw sync
    $(nix path-info .#"wshs:exe:bww")/bin/bww force-sync
else
    info variables required to run bww force sync are MISSING, skipping
fi

cat <<-EOF
Success! However, there are some remaining manual set up steps required.
«manual-setup-instructions»
EOF
#+end_src
** Bootstrapping Components
*** Note: Separate executables
Many of these snippets are also provided as separate scripts in the workstation
repository. It is handy to have these quickly available if I am debugging a
problem; the alternative, frequently, is to reconstruct these things ad-hoc.
*** Helper Functions
**** is_mac
Detects if is running on a mac.

#+NAME: is_mac_function
#+begin_src sh
function is_mac() {
    [[ "$(uname)" == 'Darwin' ]]
}
#+end_src
**** is_linux
Detects if running on linux
#+NAME: is_linux_function
#+begin_src sh
function is_linux() {
    [[ "$(uname)" == 'Linux' ]]
}
#+end_src
**** info
A simple function for logging.
#+NAME: info_function
#+begin_src sh
function info() {
    echo "INFO ========= $(date) $@"
}
#+end_src
**** mv_dated_backup
#+name: mv_dated_backup_function
#+begin_src shell
function mv_dated_backup() {
    local THEDIR="$1"
    if test -e "$THEDIR"; then
        mv "$THEDIR" "${THEDIR}-$(date +"%s")"
    fi
}
#+end_src
**** is_git_repo_cloned_at
Utility function to see if a git repo is checked out
Use the origin url as an approximate way to check if its checked out
#+name: is_git_repo_cloned_at_function
#+begin_src shell
function is_git_repo_cloned_at(){
    cd $1 && [[ "$(git remote get-url origin)" == "$2" ]]
}
#+end_src
**** clone_repo_and_checkout_at
#+name: clone_repo_and_checkout_at_function
#+begin_src shell
function clone_repo_and_checkout_at() {
    mv_dated_backup $1
    info cloning repo into $1
    git clone $2 $1
    cd $1
    info checking out commit $3
    git checkout $3
}
#+end_src
**** install_doom_emacs_no_nix
#+name: install_doom_emacs_no_nix_function
#+begin_src shell
function install_doom_emacs_no_nix() {
    {
        cd $EMACS_CONFIG_DIR
        [[ "$(git remote get-url origin)" == 'https://github.com/hlissner/doom-emacs' ]]
    } || {
        mv_dated_backup $EMACS_CONFIG_DIR
        time git clone --depth 1 https://github.com/doomemacs/doomemacs $EMACS_CONFIG_DIR/
        # alternative: use this if encounter problems
        # ~/.emacs.d/bin/doom -y install;
        # time timeout 45m bash -c 'yes | ~/.emacs.d/bin/doom install' || exit 0
        # time bash -c 'yes | ~/.emacs.d/bin/doom install' || exit 0
        time timeout 60m bash -c "yes | $EMACS_CONFIG_DIR/bin/doom install" || exit 0
        $EMACS_CONFIG_DIR/bin/doom sync
        echo FINISHED INSTALLING DOOM;
    }
}
#+end_src
*** setting up xcode (macos)
#+name: xcode_setup_function
#+begin_src shell
function xcode_setup() {
    # this will accept the license that xcode requires from the command line
    # and also install xcode if required.
    sudo bash -c '(xcodebuild -license accept; xcode-select --install) || exit 0'
}
#+end_src
External Script:
#+begin_src sh :tangle ./lib/shell/setup/xcode_setup.sh :shebang "#!/usr/bin/env bash" :noweb yes
«xcode_setup_function»
xcode_setup
#+end_src
*** check if brew is installed (macos)
#+name: is_brew_installed_function
#+begin_src shell
function is_brew_installed() {
    which brew > /dev/null
}
#+end_src
External Script:
#+begin_src sh :tangle ./lib/shell/setup/is_brew_installed.sh :shebang "#!/usr/bin/env bash" :noweb yes
«is_brew_installed_function»
is_brew_installed
#+end_src
*** set up homebrew (macos)
#+name: homebrew_setup_function
#+begin_src shell
function homebrew_setup() {
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}
#+end_src
External Script:
#+begin_src sh :tangle ./lib/shell/setup/homebrew_setup.sh :shebang "#!/usr/bin/env bash" :noweb yes
«homebrew_setup_function»
homebrew_setup
#+end_src

*** update apt and install git
#+name: update_apt_install_git_function
#+begin_src shell :noweb yes
function update_apt_install_git() {
    sudo bash -c 'apt-get update && apt-get install git'
}
#+end_src
External Script:
#+begin_src sh :tangle ./lib/shell/setup/update_apt_install_git.sh :shebang "#!/usr/bin/env bash" :noweb yes
«update_apt_install_git_function»
update_apt_install_git
#+end_src
* Nix components
** Home Manager
I use home manager as the primary method for installing and configuring software
*** flake-world equivalent to home-manager 'switch'
The pre-flake way of using home manager had a ~home-manager switch~ command
which would build and then activate the next home manager generation. This is
the flake "equivalent". Having it as a shell command makes it easier to run.

Also, this script obviously requires the ~WORKSTATION_NAME~ environment variable
to be set, which provides the 'identity' of the current machine -- not all
machines have the same home manager configurations.
#+begin_src sh :shebang "#!/usr/bin/env bash" :tangle ./bin/home-manager-flake-switch.sh :noweb yes
set -u # error in case WORKSTATION_NAME is not set
«home_manager_flake_switch_function»
home_manager_flake_switch
#+end_src
#+NAME: home_manager_flake_switch_function
#+begin_src shell
function home_manager_flake_switch() {
    nix build --no-link ~/workstation/#homeConfigurations.${WORKSTATION_NAME}.$(whoami).activationPackage --show-trace
    "$(nix path-info ~/workstation/#homeConfigurations.${WORKSTATION_NAME}.$(whoami).activationPackage)"/activate --show-trace
}
#+end_src
** Nix darwin
I actually don't use this for much of anything now, but I do know that since
home manager can't manage daemons on macos, I want to keep nix darwin around so
that I can use it for that. I had used this for setting up nix.conf, but I
decided to just unify how it was done since I have to do it another way anyway
for non-darwin machines.

Also, this script obviously requires the ~WORKSTATION_NAME~ environment variable
to be set, which provides the 'identity' of the current machine -- not all
machines have the same home manager configurations. This environment variable is
set by other mechanisms withing the workstation system.
*** command to have darwin build and switch to next generation
#+begin_src sh :shebang "#!/usr/bin/env bash" :tangle ./bin/nix-darwin-rebuild-flake.sh  :noweb yes
set -u # error in case WORKSTATION_NAME is not set
«nix_darwin_rebuild_flake_function»
nix_darwin_rebuild_flake_function
#+end_src

#+name: nix_darwin_rebuild_flake_function
#+begin_src sh
function nix_darwin_rebuild_flake() {
    nix build --extra-experimental-features "nix-command flakes" \
        ~/workstation\#darwinConfigurations.${WORKSTATION_NAME}.system
    ./result/sw/bin/darwin-rebuild switch --flake ~/workstation#${WORKSTATION_NAME}

    rm -rf ./result
}
#+end_src
* Post-bootstrap setup
* Manual installation and setup
#+NAME: manual-setup-instructions
#+begin_src org
There are unfortunately a number of things need to install and set up
manually:
- lastpass firefox extension
- vimium-ff etension
- dropbox
- icloud
- slack
- spotify
- install haskell language server in ~/bin (or somwewhere else?) for hls

These are the settings I use for slack:
- accessibility then at bottom changbe up arrow to move focus to last message
- advanced
  - when in markdown block backticks, enter should do a newline
  - format messages with markup

mac settings
- enable screen sharing, _not_ remote management
- enable remote login
- configure hammerspoon
  - open it
  - enable accessability settings
  - launch at login
#+end_src

* System update process
this is still incomplete, but some things I think
- fetch ~/worksation and ~, if can clealy rebase, do so
- run any other kind of "sync"
- on macos, run darwin-rebuild
- run home-manager switch
- run bww sync
* System "check"
I need to have a process to check that system is OK.
* Utilities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.
#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
** library of shell functions
This single file contains many of the general-purpose functions that I use in
numerous scripts etc.
#+begin_src sh :tangle ./lib/shell/funcs.sh :shebang "#!/usr/bin/env bash" :noweb yes

«is_mac_function»

«is_linux_function»

«info_function»

«bw_unlock_function»

«polite_git_checkout_function»

«mv_dated_backup_function»

«is_git_repo_cloned_at_function»

«clone_repo_and_checkout_at_function»
#+end_src
** Polite git checkout
This script provides a way to check out a repository in a directory without
clobbering the existing contents of the directory. This is useful in case the
directory might have contents that you wish to save, and you think it might be
handy to be able to i.e. ~git diff~ the contents against what git knows about
in the repository, once all of the trivial differences have been resolved (i.e.
files missing are put into place).

I used to use this for setting up dotfiles, however, I've changed the approach,
but I still think this script is handy and want to hang on to it.
#+begin_src sh :tangle ./bin/polite-git-checkout.sh :shebang "#!/usr/bin/env bash" :noweb yes
«polite_git_checkout_function»
polite-git-checkout $1 $2
#+end_src
#+name: polite_git_checkout_function
#+begin_src sh
function polite-git-checkout () {
    DIR=$1
    REPO=$2

    cd $DIR
    git init
    git remote add origin $REPO
    git fetch

    # wont work (it will have already been deleted from the index)
    git reset --mixed origin/master
    # This formulation of the checkout command seems to work most reliably
    git status -s | grep -E '^ D' | sed -E 's/^ D //' | xargs -n 1 -- git checkout
}
#+end_src
* Bitwarden and personal secrets
I have a script to set up and download various "private" information.
for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

This restores SSH keys to my local computer.
These can't be in git, and really they are essential for any meaningfully
complete workstation setup.
** bw_unlock bash function
The ~bw_unlock~ function sets the ~BW_SESSION~ environment variable in the
current shell process, which is required in order to query the bitwarden
password database.
#+NAME: bw_unlock_function
#+begin_src sh
# unlocks bitwarden, so that the `bw` program can access the bitwarden database.
bw_unlock () {
    # authtenticates bitwarden for this shell session only
    export BW_SESSION=`bw unlock --passwordfile ~/secrets/bw_pass --raw`;
}
#+end_src
* Machine profiles
*** glamdring/
*** anduril/
*** aeglos/
*** ci/
* Testing
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
set -euox pipefail

set +u
# evaluating this with set -u will cause an unbound variable error
source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
set -u

EMACS_CONFIG_DIR=~/.config/emacs

function find_emacs_init() {
  init_file="";
  for x in "$EMACS_CONFIG_DIR/early-init.el" "$EMACS_CONFIG_DIR/init.el"; do
    if [[ -f "$x" ]]; then
      init_file="$x"
      break;
    fi;
  done;
  if [[ "$init_file" = "" ]]; then
    echo "Error: Could not find emacs init file" 1>&2
    exit 43
  else
    echo "$init_file"
  fi
}

emacs_init="$(find_emacs_init)"


function assert_input() {
  local label=$1
  local expected=$2
  local actual
  read actual

  if [[ "$expected" == "$actual" ]]; then
    echo "$label is correct"
  else
    echo "$label is not correct, found '$actual', expected '$expected'"
    exit 1
  fi
}

echo "RUNNING TESTS"

EMACS_PATH=~/.nix-profile/bin/emacs
# emacs
if [ -x "$EMACS_PATH" ]; then
    echo found emacs
else
    echo EMACS NOT FOUND
    exit 1
fi

$EMACS_PATH -Q --batch --eval '(progn (princ emacs-version) (terpri))' | {
  read actual
  if [[ "$actual" == "27.1" || "$actual" == "27.2" || "$actual" == "28.1" || "$actual" == "28.2" ]]; then
    echo "emacs version is correct"
  else
    echo "emacs version is not correct, found '$actual', expected 27.1, 27.2, 28.1, or 28.2"
    exit 1
  fi
}

$EMACS_PATH -l "$emacs_init" --batch --eval '(progn (princ doom-version) (terpri))' | {
  read actual;
  if [[ "$actual" == "21.12.0-alpha" || "$actual" == "3.0.0-dev" || "$actual" == "3.0.0-pre" ]]; then
    echo "doom version is correct"
  else
    echo "doom version is not correct, found '$actual', expected 21.12.0-alpha, 3.0.0-dev, or 3.0.0-pre"
    exit 1
  fi
}

if $EMACS_PATH -l "$emacs_init" --batch --eval "(progn (require 'vterm-module nil t))"; then
  echo "emacs is able to load vterm-module, so vterm-module is compiled and ready to go";
else
  echo "error: emacs was not able to load vterm-module";
  exit 1
fi

if [ -f ~/secrets/test_secret ]; then
    echo "test secret file sucessfully synced"
    cat ~/secrets/test_secret
else
    echo "error: test secret file was missing"
fi

echo "TESTS COMPLETE"
#+end_src
** Github Actions CI
Importantly, github CI support macos environments.

Daily build to ensure that potential problems get caught (NB: I have had issues
where a working setup no longer worked due to bit rot, which would have been
caught with a regular build like this).

I am running up close to maximum execution time, so very likely I will need to
refactor/come up with some other way to do this.
#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
name: CI

on:
  push:
  schedule:
  - cron: '0 0 * * *'  # every day at midnight

jobs:
  build:
    strategy:
      matrix:
        os:
        # - macos-10.15
        - macos-latest
        - ubuntu-latest
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v3

    - name: Run a one-line script
      env:
        BW_CLIENTID: ${{ secrets.BW_CLIENTID }}
        BW_CLIENTSECRET: ${{ secrets.BW_CLIENTSECRET }}
        WS_BW_MASTER_PASS: ${{ secrets.WS_BW_MASTER_PASS }}
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes

set -xeuo pipefail

# env # are there environment variables where I can get the commit sha?

cd ~

if [ "$GITHUB_SHA" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$GITHUB_SHA"
fi

curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/bootstrap-workstation.sh > bootstrap-workstation.sh

echo BEGINNING INITIAL INSTALL

# disable native compilation, too slow for CI
export DOOM_DISABLE_NATIVE_COMPILE=true

if [ "$RUNNER_OS" == "macOS" ]; then
    bash bootstrap-workstation.sh ci-macos $WORKSTATION_BOOTSTRAP_COMMIT
else
    bash bootstrap-workstation.sh ci-ubuntu $WORKSTATION_BOOTSTRAP_COMMIT
fi

echo INSTALL PROCESS COMPLETE, TESTING

bash ~/workstation/test/test.sh
#+end_src
* TODO tasks
- [ ] have link_dotfiles script use the make-dated-backup functionality for
      any extant files.
  - maybe also should have a saved diff of what the original contents were?
  - brings up another idea: what if in ~/var/workstation_setup we had
    - logs of each setup on that computer
    - stored backup info
- [ ] write code to fix the origins of both dotfiles and workstation checkouts
  - also should have an assertion in the tests
  - should I start thinking about TDD?
- [ ] there are lots of weird little things that have accumulated in
  bootstrap-workstation.sh; try to clean some of them up
  - many things in bootstrap-workstation.sh should also become helper scripts in bin
    - mv_dated_backup
    - install git (mac and linux)? homebrew? nix?
    - place nix.conf with custom file
    - restart nix daemon, linux/macos
    - build_wshs
    - ws (an executable to run the currently built wshs), bww
  - for various installations, document the interesting parts of each
    and have subsections of the workstation config
- [ ] change setting of WORKSTATION_BOOTSTRAP_COMMIT to use env var
  its awkward having it be a cli arg, I feel the need to explain
  when we need to use it
- [ ] better document all of the workstation names that are available
- [ ] create mechanism to run for updating workstations
  - download updates to master branch of dotfiles and workstation
  - run nix stuffs when appropriate
  - maybe do bww sync?
- [ ] move various code not in workstation.org into this file
  - machine settings for each machine in workstation/hosts
  - bww
  - the ws code
  - possibly content from wssh
- [ ] finish filling in the numerous incomplete sections of prose in this document
- [ ] devise method to prevent committing manually-edited target files
  - git pre-commit-hook?
  - github action CI that runs tangle, checks for differences
- [ ] rebuild my personal laptop once all of this is stable
- [ ] port test/test.sh into wshs/haskell
- [ ] laptop-state-checking script/features
  - ensure secrets/bw_pass exists
  - ensure other secrets are there
    - check that no new secrets need to be synced
      - if any secrets have changed, list the changes
  - check if can access/ssh/etc into some other machines
  - check for updates on workstation origin
  - checks for nix (~nix store verify --all~ and ~nix-doctor~)
  - check for brew updates/state and presence of brew executable
    - brew doctor?
  - check reddup state
  - check for various execuables I care about
    - (e.g. each thing specifially installed)
    - haskell language server versions
  - check for any changes/differences in ~/
- [ ] setup hammerspoon, and especially spacehammer
- [ ] rebuild belthronding/my cloud machine
  - (has had lots of manual hacking)
- [ ] build nixos sever on gandi
- [ ] document various components of bww sync
  - how it works
  - how to use it
- [ ] get rid of rming results when darwin-rebuild script finishes (use path
  technique from home manager script)
- [ ] move host settings into this file
** quick planning for server config needs
(in rough order need to complete, to get to server-config phase of project)
goal is to get ready to provision/set up nixos cloud machines
1. [ ] use bww to sync/restore secrets on workstations
2. [ ] create a new host for nixos server
3. [ ] create script to sync updates from changes to workstation and dotfiles
   - does something like https://nixos.wiki/wiki/NixOps help?
4. [ ] figure out way to run update script on hosts that need it.
5. [ ] experiement with https://docs.hercules-ci.com/arion/ for running
   nextcloud (most urgent cloud service I want to use)
6. [ ] set up "intelligent" s3 bucket for
* COMMENT Local Variables
These are set like this so that the noweb characters don't conflict with shell
HEREDOC syntax, breaking syntax highlighting/indentation etc.
# Local Variables:
# org-babel-noweb-wrap-start: "«"
# org-babel-noweb-wrap-end: "»"
# End:
