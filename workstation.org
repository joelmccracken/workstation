#+PROPERTY: header-args    :comments both
#+OPTIONS: ^:nil ;; let an underscore be an underscore, disable sub-superscripting
#+OPTIONS: timestamp:nil
#+TITLE: Workstation
* Introduction: A Repeatable Workstation Configuration
This is my workstation configuration.

By default, our workstations are a hodge-podge of tweaks that accumulate
over the years. Quite often files etc are left over from old software we use.
Worse, files will be left over from old *versions* of software that we still
use. This makes it very confusing to tell what is essential and what is disjecta
membra.

This is my attempt to fix all that for myself, and perhaps you, dear reader, may
find it of use as well. If you have any questions, feel free to shoot me an
email or open an issue (honestly, it would be somewhat nice to know that at
least *one* other person has read this).
** Rationale: The Problem
Have you ever had a tool or setup break and had a devil of a time trying to get
it back to a working state? Over the years, I've set up many new tools to help
me with my work. But, time passes,
and things break. Sometimes I don't even notice they've broken for a long time,
so its even harder to fix. Something must have change must have changed: a
dependency, perhaps? or filesystem contents?
Or, even, perhaps I've forgotten how it is supposed to work.

This has been tricky to resolve. Especially if the tool is a hack I put
together.

What is more, to reach higher levels of productivty, it is essential to research,
develop, and use new tools for ourselves. Each of us has our own needs and
constraints. However, without a firm foundation, these rube-goldberg development
approaches are very fragile.

So, I have been trying to do just this: provide myself a repeatable, executable
workstation setup which I can extend when needed and rely on if something
unforseen happens (e.g. laptop breaks).

One final point: I've noticed over the years that there is a subtle pressure to
not install new things because I *know* it will cause a problem for me in the
future. But I think this is an anti-pattern, and needs to be fought against!
** Design choices
*** Requirements
- open source
- hackable
- where reasonable, use repeatable, automatable solutions
*** invariants checking
It is necessary to check that the computer satisfies stated requirements.
This might mean anything from "user can successfully use sudo" to "I can compile
haskell source files".

Basically, this can take shape as a script I run regularly, but more ideally it
would (also) be something that is automatically run and have information
reported to me.

Currently, the intention is that this will come in the form of running ~ws
check~, which is a part of the wshs sub-project in the wshs directory.
*** early problem reporting
Ideally, we'd like to know about problems asap. If a new update comes out, and
our whole setup proces is flawed somehow with the new update, it is important to
realize and address when I can.
* Background and History
I have had a few different setups over the
years. Accomplishing this is a lot harder than I expected.
** Literate Programming
In my experience, these workstation projects are easy to put aside for a long
time, and when you come back you can't remember how things were built.

So, this project is mostly written with literate
org mode. This gives me an easy way to document my thoughts as I work, and also
explore using ~org-mode~ for this task. I did this same thing a long time ago
with my old dotfiles setup, and I liked it, but everything else about it was a
massive pain, so it was eventually abandoned.

If you want to see how literate programming works in org mode, view this raw file.
* README
#+begin_src md :tangle ./README.md  :noweb yes
WARNING: this file is managed by tangling the file workstation.org. Do not edit directly!

# Instructions

1. download the bootstrap shell script:
`curl https://raw.githubusercontent.com/joelmccracken/workstation/master/bin/bootstrap-workstation.sh > bootstrap-workstation.sh`
2. run `bash bootstrap-workstation.sh MACHINE_NAME BRANCH
3. Profit!
4. See workstation.org for manual setup documentation
# More Information

Much more information may be found in
<a href="workstation.org">workstation.org</a>.
#+end_src
* Makefile
Used to tangle ~workstation.org~. Tangling refers to the
process of taking a literate program source and converting it to the target
"source" file for execution.

Formerly had some other targets, but now they are OBE. It may make sense to
delete this makefile if it becomes clearly unnecessary.
#+begin_src makefile :tangle ./Makefile  :noweb yes
all: tangle

tangle:
	emacs -l ~/.emacs.d/init.el -l lib/emacs/tangle-file.el --batch --tangle

.PHONY: tangle
#+end_src
And a little emacs lisp that goes with the tangle process:
#+begin_src emacs-lisp :tangle ./lib/emacs/tangle-file.el
;;; tangle-file.el --- description -*- lexical-binding: t; -*-

(add-to-list 'command-switch-alist '("--tangle" . do-tangle))

(defun do-tangle (arg)
  "Do the tangle. ARG is ignored."
  (find-file "workstation.org")
  (org-babel-tangle))

(provide 'tangle-file)

;;; tangle-file.el ends here
#+end_src
* Bootstrap process
Bootstrapping is tricky. What do you actually start with? What can you assume?
You want to keep the amount of manual steps which need to occur to a minimum.
To my mind, this starts with a shell script.
This script could either do the entire setup process, or
theoretically it could also prepare the way for another process.

For me, I currently basically have a single bash script. But what I want to do
soon is change this so that its a bash script which invokes a haskell process asap.
so the bash script would basically do the minimum amount required to set up
everything for the haskell process.
** Bootstraping Script
This script is intended to be entrypoint to this project. It can be curled to a
new machine and then run, and will set things up on that machine as necessary.
#+begin_src bash :shebang "#!/usr/bin/env bash" :tangle ./bootstrap-workstation.sh :noweb yes

set -xeuo pipefail

export NIX_PM_VERSION=nix-2.11.1
export NIX_DARWIN_VERSION=f6648ca0698d1611d7eadfa72b122252b833f86c
export HOME_MANAGER_VERSION=213a06295dff96668a1d673b9fd1c03ce1de6745

if [ -z "${1+x}" ]; then
    echo WORKSTATION_NAME must be provided as first argument
    exit 2
else
    export WORKSTATION_NAME="$1"
fi

if [ -z "${2+x}" ]; then
    export WORKSTATION_BOOTSTRAP_COMMIT=origin/master
else
    export WORKSTATION_BOOTSTRAP_COMMIT="$2"
fi

WS_DIR="$HOME/workstation"
export WORKSTATION_HOST_SETTINGS_SRC_DIR=$WS_DIR/hosts/$WORKSTATION_NAME
export WORKSTATION_HOST_CURRENT_SETTINGS_DIR=$WS_DIR/hosts/current

function is_mac() {
    [[ "$(uname)" == 'Darwin' ]]
}

function is_linux() {
    [[ "$(uname)" == 'Linux' ]]
}

function info() {
    echo INFO $(date) $@
}

info starting workstation bootstrap

is_mac && {
    info ensuring xcode is installed
    sudo bash -c '(xcodebuild -license accept; xcode-select --install) || exit 0'
    info finished ensuring xcode is installed

    info ensuring brew is installed
    which brew > /dev/null || {
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

        # install git, necessary for next step
        info installing git
        brew install git
    }
    info finished ensuring brew is installed
}

is_linux && {
    info updating apt, installing git
    sudo bash -c 'apt-get update && apt-get install git'
    info finished updating apt, installing git
}

polite-git-checkout () {
    DIR=$1
    REPO=$2

    cd $DIR
    git init
    git remote add origin $REPO
    git fetch

    # wont work (it will have already been deleted from the index)
    git reset --mixed origin/master
    # This formulation of the checkout command seems to work most reliably
    git status -s | grep -E '^ D' | sed -E 's/^ D //' | xargs -n 1 -- git checkout
}

function mv_dir_dated_backup() {
    local THEDIR="$1"
    if test -e "$THEDIR"; then
        mv "$THEDIR" "${THEDIR}-$(date +"%s")"
    fi
}

info ensuring dotfiles repo is checked out
{
    cd ~;
    [[ "$(git remote get-url origin)" == 'git@github.com:joelmccracken/dotfiles.git' ]]
} || polite-git-checkout ~ 'https://github.com/joelmccracken/dotfiles.git'
# delete doom directory, temporary solution, eventually need to just remove from this dotfiles dir
rm -rf ~/.doom.d/
info finished ensuring dotfiles repo is checked out

{
    cd $WS_DIR;
    [[ "$(git remote get-url origin)" == 'git@github.com:joelmccracken/workstation.git' ]]
} || {
    info moving workstation dir to backup location
    mv_dir_dated_backup ~/workstation
    info cloning workstation repo into ~/workstation
    git clone 'https://github.com/joelmccracken/workstation.git'
    cd workstation
    info checking out specific workstation commit $WORKSTATION_BOOTSTRAP_COMMIT
    git checkout $WORKSTATION_BOOTSTRAP_COMMIT
}

info setting current host settings directory...
info workstation host settings directory: $WORKSTATION_HOST_SETTINGS_SRC_DIR

if [ -d $WORKSTATION_HOST_SETTINGS_SRC_DIR ]; then
    info setting current host directory to $WORKSTATION_HOST_SETTINGS_SRC_DIR;
    ln -s $WORKSTATION_HOST_SETTINGS_SRC_DIR $WORKSTATION_HOST_CURRENT_SETTINGS_DIR;
else
    echo ERROR $WORKSTATION_HOST_SETTINGS_SRC_DIR does not exist, must exit
    exit 5
fi

info ensuring nix is installed
{ which nix > /dev/null; } || {
    info installing nix
    sh <(curl -L https://releases.nixos.org/nix/$NIX_PM_VERSION/install) --daemon;
}
info finished ensuring nix is installed

export NIX_REMOTE=daemon

is_linux &&  {
    info linux detected, using HEREDOC method of setting up nix.conf
(sudo bash -c 'mkdir -p /etc/nix; cat > /etc/nix/nix.conf') <<-EOF
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=
substituters = https://cache.nixos.org https://cache.iog.io
experimental-features = nix-command flakes
trusted-users = root $(whoami) runner
build-users-group = nixbld
# END OF /etc/nix/nix.conf
EOF

    info restarting nix-daemon via systemctl
    sudo systemctl restart nix-daemon.service;
    info finished restarting nix-daemon via systemctl
}


restart_mac_daemon() {
    set +e
    sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    sudo launchctl load /Library/LaunchDaemons/org.nixos.nix-daemon.plist
    set -e
}

is_mac && {
    info macos detected, restarting nix-daemon
    restart_mac_daemon
    info finished restarting nix-daemon
}

NIX_DAEMON_PATH='/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
cat $NIX_DAEMON_PATH
if [[ -e "$NIX_DAEMON_PATH" ]]; then
    set +u
    source "$NIX_DAEMON_PATH";
    set -u
fi;

is_linux && {
    sudo ~/workstation/bin/enable-passwordless-sudo.sh
    sudo apt-get update
}

is_mac && {
    info installing darwin-nix
    sudo mv /etc/nix/nix.conf /etc/nix/nix.conf.old
    cd $WS_DIR
    nix-build https://github.com/LnL7/nix-darwin/archive/${NIX_DARWIN_VERSION}.tar.gz -A installer
    ./result/bin/darwin-installer

    nix build ~/workstation\#darwinConfigurations.${WORKSTATION_NAME}.system
    ./result/sw/bin/darwin-rebuild switch --flake ~/workstation#${WORKSTATION_NAME}

    rm -rf ./result
    info finished installing darwin-nix
}

export NIX_PATH=$HOME/.nix-defexpr/channels:/nix/var/nix/profiles/per-user/root/channels${NIX_PATH:+:$NIX_PATH}
nix-channel --add https://github.com/nix-community/home-manager/archive/${HOME_MANAGER_VERSION}.tar.gz home-manager
nix-channel --update
export HOME_MANAGER_BACKUP_EXT=old

nix-shell '<home-manager>' -A install

set +u
# evaluating this with set -u will cause an unbound variable error
source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
set -u

nix build --no-link ~/workstation/#homeConfigurations.${WORKSTATION_NAME}.$(whoami).activationPackage
"$(nix path-info ~/workstation/#homeConfigurations.${WORKSTATION_NAME}.$(whoami).activationPackage)"/activate

set +u
# evaluating this with set -u will cause an unbound variable error
source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
set -u

echo "building the 'ws' script"
cd  ~/workstation/wshs
time nix build -L

echo "running the 'ws install' process"
time ./result/bin/ws install -m "$WORKSTATION_NAME";
echo "'ws install' process completed"

set +e
echo "Running final installs (install)"
if is_linux; then
    echo "is linux, installing ripgrep, fdfind, etc via apt";
    time sudo apt-get install ripgrep fd-find zsh make libtool libvterm-dev;
    echo "done running final installs";
else
    echo "linux not detected, no final installs necessary";
fi

echo outputting nix.conf to check its contents
echo I have a hunch that something is not right
cat /etc/nix/nix.conf

cat <<-EOF
Success! However, there are some remaining manual set up steps required.
<<manual-setup-instructions>>
EOF

#+end_src
* Post-bootstrap setup
* Manual installation and setup
#+NAME: manual-setup-instructions
#+begin_src org
There are unfortunately a number of things need to install and set up
manually:
- lastpass firefox extension
- vimium-ff etension
- dropbox
- icloud
- slack
- spotify
- install haskell language server in ~/bin (or somwewhere else?) for hls
- set ~/secrets/bw_pass
- bww force sync script

These are the settings I use for slack:
- accessibility then at bottom changbe up arrow to move focus to last message
- advanced
  - when in markdown block backticks, enter should do a newline
  - format messages with markup

mac settings
- enable screen sharing, _not_ remote management
- enable remote login
#+end_src
* System update process
this is still incomplete, but some things I think
- fetch ~/worksation and ~, if can clealy rebase, do so
- run any other kind of "sync"
- on macos, run darwin-rebuild
- run home-manager switch
- run bww sync
* System "check"
I need to have a process to check that system is OK.
* Utilities
** Passwordless sudo
Occasionally, sudo is extremely annoying. Having to type "sudo" in the middle of a nix-darwin rebuild really interrupts the flow. So here are a couple of scripts
to toggle passwordless sudo.
#+begin_src sh :tangle ./bin/enable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
set -eo pipefail

if [[ -z "$SUDO_USER" ]]; then
    echo ERROR: run as sudo
    exit 1
fi

TEMPFILE=$(mktemp)

cat > $TEMPFILE <<EOF
$SUDO_USER  ALL=(ALL) NOPASSWD: ALL
EOF

visudo -c $TEMPFILE

mv $TEMPFILE /etc/sudoers.d/me-passwordless-sudo
#+end_src

#+begin_src sh :tangle ./bin/disable-passwordless-sudo.sh :shebang "#!/usr/bin/env bash"
set -euo pipefail

rm /etc/sudoers.d/me-passwordless-sudo
#+end_src
* Bitwarden and personal secrets
I have a script to set up and download various "private" information.
for various reasons I've decided to try bitwarden for this, but
out of the box bitwarden doesn't really do what I need it to.

This restores SSH keys to my local computer.
These can't be in git, and really they are essential for any meaningfully
complete workstation setup.
** TODO move the bww stuff into this section of workstation
** TODO set up a testing account on bitwarden for CI/testing
** TODO set up a "check" command which shows what would change if a sync happened
* Machine profiles
** TODO set up machine-specific settings profiles
E.g. ~/workstation/profiles
*** glamdring/
*** anduril/
*** aeglos/
*** ci/
* Testing
** TODO convert all this testing to haskell
** test.sh
At this point in time, this test actually checks very little, but what it DOES check
is things that indicate that everything went right. Specifically, checking the doom version means
emacs, doom, and the whole doom setup process worked out.

I plan to move this to a Haskell project at some point, probably do it with hspec instead.
Or maybe that bats testing library. We'll see.
#+begin_src sh :tangle ./test/test.sh :shebang "#!/usr/bin/env bash" :noweb yes
set -euox pipefail

set +u
# evaluating this with set -u will cause an unbound variable error
source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
set -u

function assert_input() {
  local label=$1
  local expected=$2
  local actual
  read actual

  if [[ "$expected" == "$actual" ]]; then
    echo "$label is correct"
  else
    echo "$label is not correct, found '$actual', expected '$expected'"
    exit 1
  fi
}

echo "RUNNING TESTS"

EMACS_PATH=~/.nix-profile/bin/emacs
# emacs
if [ -x "$EMACS_PATH" ]; then
    echo found emacs
else
    echo EMACS NOT FOUND
    exit 1
fi

$EMACS_PATH -Q --batch --eval '(progn (princ emacs-version) (terpri))' | {
  read actual
  if [[ "$actual" == "27.1" || "$actual" == "27.2" || "$actual" == "28.1" || "$actual" == "28.2" ]]; then
    echo "emacs version is correct"
  else
    echo "emacs version is not correct, found '$actual', expected 27.1, 27.2, 28.1, or 28.2"
    exit 1
  fi
}


$EMACS_PATH -l ~/.emacs.d/init.el --batch --eval '(progn (princ doom-version) (terpri))' | {
  read actual;
  if [[ "$actual" == "21.12.0-alpha" || "$actual" == "3.0.0-dev" || "$actual" == "3.0.0-pre" ]]; then
    echo "doom version is correct"
  else
    echo "doom version is not correct, found '$actual', expected 21.12.0-alpha, 3.0.0-dev, or 3.0.0-pre"
    exit 1
  fi
}

if $EMACS_PATH -l ~/.emacs.d/init.el --batch --eval "(progn (require 'vterm-module nil t))"; then
  echo "emacs is able to load vterm-module, so vterm-module is compiled and ready to go";
else
  echo "error: emacs was not able to load vterm-module";
  exit 1
fi

echo "TESTS COMPLETE"
#+end_src
** Github Actions CI
Importantly, github CI support macos environments.

Daily build to ensure that potential problems get caught (NB: I have had issues
where a working setup no longer worked due to bit rot, which would have been
caught with a regular build like this).

I am running up close to maximum execution time, so very likely I will need to
refactor/come up with some other way to do this.
#+begin_src yaml :tangle ./.github/workflows/test.yml :noweb yes
name: CI

on:
  push:
  schedule:
  - cron: '0 0 * * *'  # every day at midnight

jobs:
  build:
    strategy:
      matrix:
        os:
        # - macos-10.15
        - macos-latest
        - ubuntu-latest
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v3

    - name: Run a one-line script
      run: ./test/ci.sh
#+end_src
** The environment setup script
To run CI, we have a script which, thankfully, basically mirrors the install instructions.

Importantly, this does a LOT of things, such as install nix, home-manager, etc, and eventually runs
the test script.
#+begin_src sh :tangle ./test/ci.sh :shebang "#!/usr/bin/env bash" :noweb yes

set -xeuo pipefail

# env # are there environment variables where I can get the commit sha?

cd ~

if [ "$GITHUB_SHA" == "" ]; then
    WORKSTATION_BOOTSTRAP_COMMIT=master
else
    WORKSTATION_BOOTSTRAP_COMMIT="$GITHUB_SHA"
fi

curl https://raw.githubusercontent.com/joelmccracken/workstation/$WORKSTATION_BOOTSTRAP_COMMIT/bootstrap-workstation.sh > bootstrap-workstation.sh

echo BEGINNING INITIAL INSTALL

# disable native compilation, too slow for CI
export DOOM_DISABLE_NATIVE_COMPILE=true

if [ "$RUNNER_OS" == "macOS" ]; then
    bash bootstrap-workstation.sh ci-macos $WORKSTATION_BOOTSTRAP_COMMIT
else
    bash bootstrap-workstation.sh ci-ubuntu $WORKSTATION_BOOTSTRAP_COMMIT
fi

echo INSTALL PROCESS COMPLETE, TESTING

bash ~/workstation/test/test.sh
#+end_src
* TODO tasks
- [ ] echo instructions on what to do once bootstrap workstation has completed
- [ ] add support for secrets setup/restoration
- [ ] build nixos sever on gandi
- [ ] experiment with seeing if I can use home manager to set nix.conf
    I currently have two ways that I set up the nix.config file: via darwin nix and
    shell script. debian/ubuntu doesn't have anything anything like darwin-nix, so
    if I want to get rid of the duplicate method, home manager might work. seems
    that home manager supports this:
    https://nix-community.github.io/home-manager/options.html#opt-nix.settings
- [ ] rebuild belthronding/my cloud machine
  - (has had lots of manual hacking)
- [ ] go through the commits and document anything that I think could use
  documenting
- [ ] there are lots of weird little things that have accumulated in
  bootstrap-workstation.sh; try to clean some of them up
- [ ] figure out how to get bww sync to happen automatically
- [ ] devise method to prevent committing manually-edited target files
  - git pre-commit-hook?
  - github action CI that runs tangle, checks for differences
- [ ] rebuild my personal laptop once all of this is stable
- [ ] port test/test.sh into wshs/haskell
- [ ] move various code not in workstation.org in here
- [ ] laptop-state-checking script/features
  - ensure secrets/bw_pass exists
  - ensure other secrets are there
    - check that no new secrets need to be synced
  - check if can access/ssh/etc into some other machines
  - check for updates on ~workstation origin
  - checks for nix (~nix store verify --all~ and ~nix-doctor~)
  - check for brew updates/state and presence of brew executable
    - brew doctor?
  - check reddup state
  - check for various execuables I care about
    - (e.g. each thing specifially installed)
    - haskell language server versions
  - check for any changes/differences in ~/
- [ ] setup hammerspoon, and especially spacehammer
- [ ] finish filling in the numerous incomplete prose in this document
** quick planning
(in rough order need to complete, to get to server-config phase of project)
goal is to get ready to provision/set up nixos cloud machines
1. [ ] backport changes to workstation.org
2. [ ] use bww to sync/restore secrets on workstations
3. [ ] create a new host for nixos server
4. [ ] create script to sync updates from changes to workstation and dotfiles
   - does something like https://nixos.wiki/wiki/NixOps help?
5. [ ] figure out way to run update script on hosts that need it.
6. [ ] experiement with https://docs.hercules-ci.com/arion/ for running
   nextcloud (most urgent cloud service I want to use)
7. [ ] set up "intelligent" s3 bucket for
